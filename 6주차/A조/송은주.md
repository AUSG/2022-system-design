## 7장: 분산 시스템을 위한 유일 ID 생성기 설계

- 유일 ID 생성기를 설계한다? auto_increment 속성을 사용하면 되지 않을까?
→ 분산 환경에서는 이 접근법이 통하지 않으며, 서버 한대로는 요구 감당 불가능.

- 분산 시스템에서 유일성이 보장되는 ID를 만들기 위해서는?

**1. 다중 마스터 복제**
![](https://velog.velcdn.com/images/eunz_juu/post/3980a2ae-df6f-4ca6-b20a-f8207652ef1c/image.png)
- 데이터 베이스의 auto increment 기능을 활용 
→ 하지만 id 값을 k (데이터베이스의 서버 수) 만큼 증가시키며 생성
	
```
[장점] 
	1. DB 수를 늘리는 만큼 초당 생산가능 ID 수도 늘릴 수 있으므로 규모 확장성 문제를 어느 정도 해결 가능

[단점]
    1. 여러 데이터 센터에 걸쳐 규모 늘리기 어려움
    2. ID 유일성은 보장되지만, 시간흐름에 맞추어 커지도록 보장 불가능
    3. 서버 추가, 삭제 시 잘 동작하도록 만드는 것이 어려움
```
**2. UUID**
- 시스템에 저장되는 정보를 유일하게 식별하기 위한 128 비트짜리 수로, 충돌 가능성이 매우 낮음
```
[장점] 
	1. UUID 는 서버 간 조율 없이 독립적인 생성 가능하므로 동기화 이슈가 없음
[단점] 
	1. ID가 128비트여서 길이가 길다
    2. 시간순 정렬이 불가능
    3. 숫자가 아닌 값이 포함된다
```

**3. 티켓서버**
![](https://velog.velcdn.com/images/eunz_juu/post/9e49d55c-cb9a-499b-be02-2c595da3e4c6/image.png)
- auto_increment 기능을 갖춘 DB 서버 (티켓 서버)를 중앙집중형으로 하나만 사용한다

```
[장점]
	1. 유일성이 보장된, 숫자로만 구성된 ID를 만들 수 있음
    2. 구현하기 쉬우며, 중소 규모의 애플리케이션에 적합함
[단점]
	1. 타켓서버가 SPOF (Single Point Of Failure) 가 되어, 
    장애 발생 시 해당 서버를 이용하는 모든 시스템이 영향을 받음
```

**4. 트위터 스노플레이크 접근법**
![](https://velog.velcdn.com/images/eunz_juu/post/b655d639-4a31-4f17-9209-8db7b2f22c41/image.png)

1. sign : 1비트로, 음수/양수 구분
2. timestamp : 기원시각(epoch) 이후 몇 밀리초가 경과했는지 나타냄
3. 데이터센터 id (5bit): 2^5=32개의 데이터센터 지원 가능
4. 서버 id (5bit): 2^5=32개의 서버 사용 가능
5. 일련번호 (sequence)
	- 각 서버에서는 id 생성할 때마다 이 값을 1씩 증가시키고, **_1ms가 지날때마다 0으로 초기화_**
    - 어떤 서버가 같은 ms 동안 1개 이상의 id를 만들어낸 경우에만 0보다 큰 값 가짐

- 41bit로 표현가능한 timestamp 최댓값은 2^41-1초로, 약 69년간 사용 가능.
- 따라서 기원 시각을 현재에 가깝게 맞추어 오버플로가 발생하는 시점을 늦춰 놓는다
(69년 지나면 기원 시각 변경 or ID 체계를 다른 것으로 이전)


#### 추가 논의 가능한 사항
1. 시계 동기화 : 하나의 서버가 여러 코어나, 물리적으로 독립된 여러 장비에서 실행되는 경우 전부 다른 시계를 사용할 수 있다
→ NTP 로 해결 가능
2. 각 절의 길이 최적화 : 동시성이 낮고, 수명이 긴 애플리케이션은 일련번호 길이 줄이고, 타임스탬프 절의 길이 늘린다
3. 고가용성 : ID 생성기는 필수 불가결 컴포넌트로, 높은 가용성 제공해야 함


## 8장 : URL 단축기 설계

- 필요한 API
	1. 새 단축 URL 을 리턴하는 API
    	- 단축할 URL을 인자로 실어 POST 요청을 보내고 단축된 URL을 반환받는다
	2. URL 리디렉션용 API
    	- 단축 URL에 대한 HTTP 요청이 오면 원래 URL로 보내준다. 

![](https://velog.velcdn.com/images/eunz_juu/post/4d78dfee-fe73-4ad7-99c4-a7c6bc6ca462/image.png)

- 301 Permanently Moved
	
    - URL에 대한 HTTP 요청 처리 책임이 `영구적으로` Location 헤더에 반환된 URL로 이전되었다는 응답
    - 영구이전이므로, 브라우저는 응답을 `캐시` 하여 추후 같은 단축 URL 로 요청을 보낼 때, 캐시된 원래 URL 로 요청을 보냄
    
- 302 Found
	
    - 주어진 URL로의 요청이 `일시적으로` Location 헤더가 지정하는 URL에 의해 처리되어야 함
    - 클라이언트의 요청이** 늘 단축 URL 서버에 먼저 보내지고**, 원래 URL로 리디렉션

- 서버 부하를 줄이기 위해서는 301 응답을 사용하여, **첫번째 요청만 단축 URL 서버로** 전송되도록 한다
- **트래픽 분석**이 중요할 시, 302 응답을 사용하여, 어떤 곳에서 클릭이 발생하는지, 그 비율을 추적한다

- URL 리디렉션은 해시테이블로 가장 직관적으로 표현 가능 
<단축 URL, 원래 URL> 의 형태로 구성하여 단축 URL을 키값으로 하여 원래 URL 찾기
→ 하지만 해시테이블은 메모리 비용으로 인해 실제 시스템에 쓰기는 어려우므로 **<단축URL, 원래 URL> 순서쌍을 RDBMS에 저장한다**

책에서 정한 요구사항 : 단축 URL (=hashValue) 에 구성될 수 있는 문자가 62개이고, 10년간 3650억 개의 URL을 만들어내기 위해서 필요한 hashValue의 길이는 7

- 해시 함수 구현에 쓰일 기술

**1. 해시 후 충돌 해소**	
![](https://velog.velcdn.com/images/eunz_juu/post/f20e1660-9ab5-4655-afb2-81b55b3e83c7/image.png)

- CRC32, MD5, SHA-1 과 같은 해시 함수를 이용하여 URL 을 축약
- 만약 이렇게 만든 URL 도 7글자보다 길다면, 계산된 해시값에서 7글자만 이용한다 
    → 이 경우, 해시 결과 충돌할 확률이 높아짐
    → 충돌 발생 시, 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙임

```
- 단축 URL의 길이가 고정됨
- 충돌이 가능하므로 해소 전략 필요
- ID로부터 단축 URL을 계산하는 방식이 아니라서 다음에 쓸 URL 알아낼 수 없음
```

**2. base-62 변환**
- hashValue에 사용할 수 있는 문자 개수가 62개이므로 62진법 사용
- 0은 0, 10은 a, 36은 A 이런식으로 문자와 숫자를 대응하여 11157 = 2TX 와 같이 변환

```
- 단축 URL의 길이가 가변적
- ID가 1씩 증가하는 값이라고 가정하면, 다음에 쓸 단축 URL이 무엇인지 쉽게 알아낼 수 있어서 보안상 문제 존재
```

![](https://velog.velcdn.com/images/eunz_juu/post/7ee55e75-e56e-4e26-a6c0-b9424bb4b796/image.png)

- URL 리디렉션 상세 설계
![](https://velog.velcdn.com/images/eunz_juu/post/4aaccb74-5b09-4f06-bad0-1d66337c552a/image.png)
- 쓰기보다 읽기를 자주하는 시스템으로, <단축 URL, 원래 URL> 쌍을 캐시에 저장하여 성능 높임

1. URL 클릭
2. 로드밸런서가 요청을 웹 서버에 전달
3. 단축 URL이 이미 캐시에 있는 경우 원래 URL을 바로 꺼내서 클라이언트측에 전달
4. 캐시에 해당 단축 URL이 없는 경우 DB에서 꺼냄
5. DB에서 꺼낸 URL을 캐시에 넣은 후 사용자에게 반환