# 7, 8장

# 7장 분산 시스템을 위한 유일 ID 생성기 설계

- ID는 유일해야 한다. (unique)
- ID는 숫자로만 구성되어있어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야한다.
- ID는 64비트로 표현될 수 있는 값이어야한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.

## 다중 마스터 복제 (multi-master replication)

!![image](https://user-images.githubusercontent.com/44438366/196414647-4bff6e03-e340-49d0-99aa-b226540cb8db.png)

- 데이터베이스의 auto_increment 기능을 활용.
- 현재 사용 중인 데이터벰이스 서버의 수를 `k`라고 하고, 다음 ID 값을 구할 때 이전 키에서 k만큼 더해주는 방법

### 장점

- 데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘어난다,

### 단점

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.

## UUID(Universally Unique Identifier)
![image](https://user-images.githubusercontent.com/44438366/196414913-db3c64b0-662d-4199-bd67-f3172d2aaee7.png)

- 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 짜리 수
- UUID 값은 충돌 가능성이 지극히 낮다.
- 서버 간 조율 없이 독립적으로 생성 가능하다.

### 장점

- UUID를 만드는 것은 단순하다.
- 동기화 이슈도 없다. 서버 간의 조율이 필요 없으므로
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장이 쉽다.

### 단점

- ID가 128비트로 길다. 이번 문제에서는 쓸 수 없음
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

## 티켓 서버(ticket server)
![image](https://user-images.githubusercontent.com/44438366/196415088-9d99077b-b25a-41b3-80d0-2b7f76329f60.png)


- 이 방법은 auto_increment 기능을 갖춘 데이터베이스 서버를 티켓 서버로 하고, 중앙 집중형으로 하나만 사용하는 것

### 장점

- 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.

### 단점

- 티켓 서버가 단일 장애 지점(SPOF, Single-Point-of-Failure)이 된다. 결국 이 이슈를 해결하기 위해 티켓 서버를 여러 대 준비하게 되는데, 그렇게 하면 데이터 동기화같은 새로운 문제가 발생한다.

## 트위터 스노플레이크 접근법

- 이번 문제의 요구사항을 만족할 수 있다.
- divide and conquer 전략을 사용
- 생성해야하는 ID를 여러 섹션으로 분할


![image](https://user-images.githubusercontent.com/44438366/196415156-9d827b9e-65e5-4a7f-8285-5e9b88f00591.png)

- 사인(sign) bit: 1비트, 음수와 양수를 구별하는데 사용
- 타임스탬프(timestamp): 41비트, 기원 시각(epoch) 이후로 몇 밀리초가 경과했는지를 나타내는 값이다.
    - 2^41 -1 = 2199023255551 밀리초.
    - 2199023255551 / 1000 / 365일 / 24시간 / 3600초 → 대략 69년.
- 데이터센터 ID: 5비트, 2^5=32개의 데이터센터를 지원할 수 있다.
- 서버 ID: 5비트, 데이터 센터 당 32개의 서버를 사용할 수 있다.
- 일련번호(sequence): 12비트, 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화된다. 2^12 = 4096 개의 값을 가질 수 있다.
    - 어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

# 8장 URL 단축기 설계

개략적 추정

- 쓰기 연산 : 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산 : 1억 / 24 / 3600 = 1160 (write/s)
- 읽기 연산 : 읽기 연산과 쓰기 연산 비율은 10:1이라고 하자. 그 경우 읽기 연산은 초당 11,600회 발생한다 (1160 x 10 = 11,600(read/s))
- URL 단축 서비스를 10년간 운영한다고 가정하면 1억 x 365 x 10 = 3650억 개의 레코드를 보관해야 한다.
- 축약 전 URL의 평균 길이는 100이라고 하자.
- 따라서 10년 동안 필요한 저장 용량은 3650억 x 100 바이트 = 36.5 TB이다.
    - 아래 표에 따라 7글자면 충분할 것 같다.

![image](https://user-images.githubusercontent.com/44438366/196415235-e731ef30-2549-4041-be1b-d3171cb503c0.png)

> Url shortener
> 
> 1. Ui적으로 프론트엔드 기술을 보여줄게 없음.
> 2. 알고리즘을 정확히 이해했는지
> 3. 알고리즘을 위주로 잘 설계했는지
> 4. 퍼포먼스.
>     1. Long url을 넣으면 db index가 나오고 그걸 base 62로 인코딩함. 특수문자 뺀 base 62해야 1차는 맞는 것.
>     2. Shorten url을 db에 저장하면 안됨.
>         1. Base 62 디코딩을 해야함. Direct로 찾으면됨. 직접 저장할 필요가 없이 DB에는 long url만 저장해야 한다.
>         2. 여기까지는 1/5은 함.
> 5. 응용범위까지 갔는지.
>     1. Long url을 넣으려고 db에 넣었다. 그러면 full search를 해야함. Short가 날라오면 db에서 다이렉트로 서치할 수 있는데, long url이 들어왔으면, 풀서칭이 일어난다. 이걸 해결한 사람은 없음.
>     2. **커넥션** **풀**을 고려했는지.
>     3. 캐시를 쓰면 된다. Redis에 넣어둠. 있으면 리턴
>     4. 데이터베이스 샤딩. 분배기술.
>         1. 데이터가 엄청나게 많을 때, 내 들어온 주소가 a로 시작하면 1번 db, b로 시작하면 2번 db 규격을 나눈 것이다. 특정 db만 뒤지면 된다. 데이터 개수가 줄고.. 이런 로직을 짠다.
