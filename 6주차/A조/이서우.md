# < 6장 키-값 저장소(키-값 데이터베이스) 설계>

- 비 관계형 데이터베이스.
- 키는 유일해야 한다
- 키에 매달린 값은 키를 통해서만 접근할 수 있다
- 키 : 일반 텍스트나 해시 값일 수도 있고, 짧을수록 좋다
- 값 : 문자열 OR 리스트 OR 객체 등등, 무엇이 오든 상관하지 않는다
- ex) 아마존 다이나모, memcached, 레디스 등
- put(key,value) : 키-값 쌍을 저장소에 저장한다
- get(key) : 인자로 주어진 키에 매달린 값 꺼낸다

<br>

# 단일 서버 키-값 저장소

- 키-값 쌍 전부를 메모리에 해시 테이블로 저장
  <br> -> 빠른 속도 보장 But, 모든 데이터를 메모리 안에 두는 것이 불가능 할 수 있다
  <br> -> 개선 : 데이터 압축 / 자주 쓰이는 데이터만 메모리에 두기
  <br> -> 그래도 한 대 서버로는 부족하여 "분산 키-값 저장소" 필요
  <br><br>

# 분산 키-값 저장소 = 분산 해시 테이블

- 키-값 쌍을 여러 서버에 분산

## CAP 정리

데이터 일관성, 가용성, 파티션 감내라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능
<br> = 어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생돼야 한다

- 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다
- 가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다
- 파티션 감내 : 두 노드 사이에 통신 장애가 발생하였음에도 시스템은 계속 동작해야 한다
  <br>
  <br>

- CP 시스템 : 일관성 & 파티션 감내를 지원, 가용성 희생
- AP 시스템 : 가용성 & 파티션 감내를 지원, 데이터 일관성 희생
- CA 시스템 : 존재하지 X ( <= 네트워크 장애는 피할 수 없는 일로 여겨지므로 분산 시스템은 반드시 파티션 문제를 감내할 수 있게 설계돼야 함)

=> 분산 키-값 저장소를 만들 때는 그 요구사항에 맞도록 CAP 정리를 적용해야한다

<br>

## 시스템 컴포넌트

### 데이터 파티션

대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능
<br> ->데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장
<br>-> 이때, 데이터를 여러 서버에 고르게 분산 가능한지, 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화 할 수 있는지 따져봐야한다
<br> -> 안정 해시 사용 (5장 참고)

<br><br>

### 데이터 다중화

- 높은 가용성과 안정성을 확보하기 위해서는 데이터를 N(튜닝 가능한 값)개 서버에 비동기적으로 다중화할 필요가 있다
- N개 서버를 선정하는 방버 : 어떤 키를 해시 링 위에 배치 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개의 서버에 데이터 사본을 보관
- 가상 노드를 사용한다면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있으므로 같은 물리서버를 중복 선택하지 않도록 해야한다

<br><br>

### 데이터 일관성

- 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야한다
- 정족수 합의 프로토콜 사용 -> 읽기/쓰기 연산 모두에 일관성 보장
- N = 사본 개수
- W = 쓰기 연산에 대한 정족수, 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야한다
- R = 읽기 연산에 대한 정족수, 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야한다
  <br><br>
  요구되는 일관성 수준에 따라 W,R,N의 값을 정하면 된다
- R=1, W=N : 빠른 읽기 연산에 최적화된 시스템
- W=1, R=N : 빠른 쓰기 연산에 최적화된 시스템
- W+R > N : 강한 일관성이 보장됨
- W+R <= N : 강한 일관성이 보장되지 않음

<br>

#### 일관성 모델

- 강한 일관성 : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다. 클라이언트는 절대 낡은 데이터를 보지 못한다 => 새로운 요청의 처리가 중단되기 때문에 고가용성 시스템에는 적합하지 않다
- 약한 일관성 : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못 할 수 있다
- 최종 일관성 : 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델 => 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 일관성이 깨질 수 있는데 이는 클라이언트가 해결해야 한다

### 비 일관성 해소 기법 : 데이터 버저닝

- 데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아지므로 버저닝과 벡터 시계 사용!
- 버저닝 : 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것, 각 버전의" 데이터는 변경 불가능

### 장애 처리

#### 장애 감지

- 보통 두 대 이상의 서버가 똑같이 서버 A의 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주
- 가십 프로토콜 같은 분산형 장애 감지 솔루션을 채택하는 편이 효율적
- 가십 프로토콜 : 각 노드는 멤버십 목록을 유지하고 주기적으로 자신의 박동 카운터를 증가시킨다 -> 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다 -> 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신하는데 어떤 멤버의 박동 카운터 값이 지정된 시간동안 갱신되지 않으면 해당 멤버는 장애상태로 간주

#### 일시적 장애 처리

쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시링에서 고른다
<br> -> 장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리하고 해당 서버가 복구되었을 때 일괄 반영하여 데이터 일관성을 보존한다
<br> -> 이를 위해 임시로 쓰기 연산ㅇ르 처리한 서버에는 그에 관한 단서를 남겨둔다 ( 단서 후 임시 위탁 기법 )

#### 영구 장애 처리

사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 "머클 트리" 사용

머클트리 = 해시트리

- 각 노드에 그 자식 노드들에 보관된 값의 해시 또는 자식 노드들의 레이블로부터 계산된 해시값을 레이블로 붙여두는 트리
- 해시 트리를 사용하면 대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증할 수 있다

### 데이터 센터 장애 처리

- 정전, 네트워크장애, 자연재해 등 다양한 이유로 발생할 수 있다
- 데이터를 여러 데이터 센터에 다중화하는 것이 중요

### 시스템 아키텍쳐 다이어그램

- 클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API (get, put)과 통신한다
- 중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드다
- 노드는 안정 해시의 해시 링 위에 분포한다
- 노드를 자동으로 추가, 삭제할 수 있도록 시스템은 완전히 분산된다
- 데이터는 여러 노드에 다중화된다
- 모든 노드는 클라이언트 API, 장애감지, 데이터 충돌 해소, 다중화 등등 전부를 지원해야 한다
