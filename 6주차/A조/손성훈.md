# 분산 시스템을 위한 유일 ID 생성기

### 다중 마스터 복제

- 새로운 레코드를 만들 때마다 k(서버 수)만큼 증가한 값을 ID로 쓴다.
- 서로 영향을 끼치지 않고 ID를 만들기 때문에 성능이 보장된다.

**단점**

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- 서버의 추가 및 삭제가 어렵다.
- ID가 시간 흐름에 맞추어 커지도록 보장할 수 없다. (왜 필요한 거지)

### UUID (Universally Unique Identifier)

- 충돌 가능성이 지극히 낮은 128비트 문자열
- 서버의 조율 없이 각자 만들 수 있다.

**장점**

- 단순하고 동기화 이슈가 없다.
- 확장에 용이하다.

**단점**

- 128비트로 비교적 길다.
- 시간과 연관성이 없다.
- 숫자만 있지 않고 문자도 포함된다.

### 티켓 서버

- ID를 만드는 서버를 따로 두고 이 서버에서 DB에게 ID값을 준다.

**장점**

- 유일성이 보장된다.

**단점**

- SPOF 문제 발생
- 티켓 서버를 여러 대 두면 동기화 문제 발생

### 트위터 스노우플레이크

패킷 구성하듯 `64`비트를 여러 구역으로 쪼개서 값을 부여한다.

![Snowflake](https://ibb.co/jTm8jB2)

- `01`, sign bit : 일단 예약 비트이다.
- `41`, timestamp : epoch(아무 시간이나 정함) 이후 millisecond
- `05`, datacenter id : 총 32개의 데이터센터를 표시
- `05`, server id : 데이터센터당 32개의 서버를 표시
- `12`, serial number : 각 서버에서 이 숫자를 1씩 증가

**특징**

- 타임스탬프가 제일 앞에 있기 때문에 시간에 따른 정렬이 가능하다.
- 타임스탬프는 $2^{41}-1$ 밀리초, 즉 69년만 측정 가능하다.
- 일렬번호가 의미하는 것 : 한 서버가 1ms 내에 최대 2^12개의 ID를 만들 수 있다.
  - 동시성이 적은 어플리케이션의 경우 일렬번호를 줄일 수 있다.
  - 또 데이터센터와 서버 수도 적절히 예측해 조절한다.

# URL 단축기

### API Endpoint

클라이언트가 서버와 소통하기 위해 거치는 관문

- URL 단축용 엔드포인트 : URL 단축 요청이 오면 결과를 반환한다.
- URL 리다이렉션용 엔드포인트 : HTTP 요청을 새 URL로 돌린다. (301 or 302)

### URL Redirection

- 301 (Paermanently Moved)
  - 영구적으로 URL이 리다이렉션되기 때문에 브라우저는 반환된 URL을 캐싱한다.
  - 그리고 나중에 요청을 보낼 때 브라우저 단에서 URL을 바꿔서 보낸다.
  - 이거 테스트 환경에서 잘 못 쓰면 많이 고생한다.
- 302 (Found)
  - 일시적으로 리다이렉션된다
  - 매번 URL 단축기 서버를 거쳐 가기 때문에 트래픽 분석하기 좋다.

### URL 단축

- 긴 URL을 해싱해서 짧은 URL을 만든다.
- 짧은 URL을 긴 URL로 복원해야 한다.

## 설계

### 데이터 모델

- 해시 테이블 : 유용하지만 메모리는 비싸다.
- RDBMS : 단축 URL을 인덱스로 삼고 찾는다.

### 해시 함수

- 단축 URL은 숫자와 알파벳으로만 구성된다. ⇒ 한 문자에 62개의 경우의 수가 나온다.
- (추정치에 따르면) 3650억 개의 URL을 만들어야 하므로 7자리면 충분하다. ($62^7 \approx 3.5 \times 10^{12}$)

### 해시 충돌 해소

- 해싱을 하면 충돌이 발생하고 충돌을 해소하기 위해서는 임의의 문자열을 덧붙여야 한다.
- 이렇게 하면 DB에 질의가 많아지고 성능이 저하된다.
- DB 대신 블룸 필터를 쓰면 공간 효율이 좋아진다.
  - false positive를 감안해도 거의 대부분을 거를 수 있다.

### base 62 변환

- 앞서 한 문자에 62개의 경우의 수가 나온다고 했다. (숫자와 알파벳)
- 긴 URL은 결국 0과 1로 된 비트맵이다.
- 긴 URL을 62진법으로 변환한다.

## 동작

1. 클라이언트 → 웹 서버 : URL을 묻는다.
2. 웹 서버 → 캐시 : 캐시를 뒤져본다.
3. 웹 서버 → DB : 캐시가 miss 나면 DB를 찾는다.
4. 웹 서버 : DB도 miss 나면 단축 URL을 생성하고 DB에 저장한다.
    1. 캐시에 저장할 지는 캐시 전략에 따라 다르다.
5. 웹 서버 → 클라이언트 : 결과를 반환한다.
