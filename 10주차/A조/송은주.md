## 13장: 검색어 자동완성 시스템

#### 가장 많이 이용된 검색어 k개를 자동완성하여 출력하는 시스템 설계하기!


**요구사항**
1. 빠른 응답속도
2. 연관성 있는 단어
3. 인기도 등의 순위 모델에 의한 정렬
4. 많은 트래픽을 감당 가능한 규모 확장성
5. 장애 발생해도 사용가능한 고가용성

- 시스템은 두 부분으로 나뉜다.
    - 데이터 수집 서비스 : 사용자가 입력한 질의 실시간 수집
    - 질의 서비스 : 주어진 질의에 5개의 인기 검색어 정렬해서 보여줌

- 데이터 수집 서비스 
	- 질의문과 사용빈도 저장하는 빈도테이블에서 5개의 검색어를 가져갈 수 있음
    → 데이터가 많아지는 경우 병목
    
    
> **트라이 자료구조**
	
- 트라이
    - 트리형태의 자료구조
    - 루트 노드는 빈 문자열
    - 각 노드는 글자 하나를 저장, 26개의 자식노드를 가질 수 있음
    - 각 노드는 하나의 단어, 또는 접두어 문자열
        ![](https://velog.velcdn.com/images/eunz_juu/post/f8a47a6b-99df-4863-8934-c2d9819dbcc6/image.png)

p : 접두어의 길이 
n : 트라이 안에 있는 노드 개수
c : 주어진 노드의 자식 노드 개수

- 접두어 'te' 를 찾는다.
- te 노드부터 시작하는 하위 노드를 탐색해서 모든 유효노드를 찾음
→ tea, ted, ten
- 유효 노드를 정렬하여 2개만 골라낸다. 
→ ten, ted

`시간 복잡도` : O(p)+O(c)+O(clogc)  
최악의 경우, k개 결과를 얻으려고 전체 트라이를 다 검색해야 할 수도 있음
아래의 2가지 방법으로 해결 가능하다.

1. 접두어의 최대 길이 제한
- 긴 검색어 입력하는 일이 거의 없으므로, O(p) → O(1) 로 변경
2. 각 노드에 인기 검색어 캐시
- 각 노드에 질의어를 캐시해두어, 질의 시간복잡도를 낮출 수 있지만, 각 노드에 저장공간이 많이 필요함

- 접두어 노드 찾는 시간 O(1)
- 인기 검색어 5개 찾는 시간 O(1) 로 감소 (검색 결과가 이미 캐싱되어 있으므로)
→ 따라서, 전체 알고리즘 복잡도 O(1)

> **데이터 수집 서비스**

- 질의가 입력될 때마다 트라이를 갱신하면 질의 서비스는 심각하게 느려짐
- 트라이가 만들어지면, 인기 검색어는 그다지 자주 바뀌지 않음

`트라이 캐시` : 
트라이 데이터를 메모리에 유지해서 읽기 연산 성능을 높인다.
매주 트라이 DB의 스냅샷을 떠서 갱신한다
`트라이 데이터베이스` : 지속성 저장소
1. 문서 저장소
2. 키-값 저장소
- 트라이의 모든 접두어를 `해시 테이블 키`로 변환
- 트라이 노드에 보관된 모든 데이터를 `해시 테이블 값`으로 변환

> 질의 서비스

- 질의 서비스는 속도가 생명이므로, 아래와 같은 방안으로 최적화할 수 있다.
1. AJAX 요청
- 요청 주고 받기 위해 페이지를 새로고침할 필요X
2. 브라우저 캐싱
- 자동완성 검색어 제안은 자주 바뀌지 않으므로, 해당 데이터를 브라우저 캐시에 넣어두면 후속 질의 결과를 꺼내가면 됨
3. 데이터 샘플링
- 모든 질의 결과를 로깅하지 않고 N개 요청 중 1개만 로깅하도록 함

> 트라이 연산

- 트라이 생성
	
    - 데이터 분석 서비스의 로그, DB로부터 취합된 데이터를 이용하여 작업 서버가 생성
- 트라이 갱신
	
    - 매주 1번 갱신 (새로운 트라이 생성 후 기존 트라이 대체)
    - 트라이의 각 노드를 개별 갱신
- 검색어 삭제
	- 트라이 캐시 앞에 필터 계층 두어 부적절한 질의어는 필터링
- 저장소 규모 확장
	
    - 첫 글자 기준 샤딩
    - 만약 26대 서버 이상 필요하다면, 계층적 샤딩 필요
    	- 첫번째 글자는 첫번째 레벨의 샤딩에 사용
       - 두번째 글자는 두번째 레벨의 샤딩에 사용

       
       