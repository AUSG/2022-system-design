# 13장 검색어 자동 완성 시스템

# 1 단계 문제 이해 및 설계 범위 확정

## 요구사항

- 빠른 응답 속도 : 사용자가 검색어를 입력함에 따라 자동완성 검색어도 충분히 빨리 표시돼야 함
- 연관성: 자동완성되어 출력되는 검색어는 사용자가 입력한 단어와 연관된 것이어야 함
- 정렬 : 결과는 인기도 등의 순위 모델에 의해 정렬돼 있어야 한다
- 규모 확장성 : 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능해야 한다
- 고가용성 : 시스템의 일부에 장애가 발생하거나, 느려지거나 해도 시스템은 계속 사용 가능해야 한다

## 계략적 규모 추정

- 일간 능동 사용자는 천만 명으로 가정
- 평균적으로 한 사용자는 매일 10건의 검색 수행
- 질의할 때마다 평균적으로 20바이트의 데이터를 입력한다고 가정
- 검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다. 따라서 평균적으로 1회 검색당 20건의 요청이 백엔드로 전달된다
- 대략 초당 24000건의 질의(QPS)가 발생, 최대 QPS는 48000
- 질의 가운데 20%정도는 신규 검색어라고 가정. 매일 0.4GB의 신규데이터가 시스템에 추가
  <br><br>

# 2단계 계략적 설게안 제시 및 동의 구하기

개략적으로 보면 시스템은 두 부분으로 나뉜다

- 데이터 수집 서비스(data gathering service) : 사용자가 입력한 질의를 실시간으로 수집하는 시스템
- 질의 서비스(query service): 주어진 질의에 다섯개의 인기 검색어를 정렬해 내놓는 서비스이다

## 데이터 수집 서비스

질의문과 사용빈도를 저장하는 빈도 테이블이 있다고 가정하면 처음에 이 테이블은 비어 있는데 사용자가 단어를 순서대로 검색하면 그 상태가 다음과 같이 바뀌어 나간다

## 질의 서비스

빈도 테이블이 있을때 질의문을 저장하는 필드인 query와 질의문이 사용된 빈도를 저장하는 필드인 frequency가 있다. 사용자가 tw를 검색창에 입력했을때 가장 많이 사용된 5개 검색어는 다음과 같은 SQL 질의문을 이용해 계산할 수 있다

```
SELECT * FROM frequency_table
WHERE query Like `prefix%`
ORDER BY frequency DESC
LIMIT 5
```

데이터 양이 적을 땐 괜찮지만 데이터가 아주 많아지면 데이터베이스가 병목이 될 수 있다
<br><br>

# 3단계 상세 설계

## (1) 트라이 자료구조

- 개략적 설계안에서는 관계형 데이터베이스를 저장소로 사용했지만 이건 효율적이지 않아 트라이를 사용해 이 문제를 해결

### 트라이

- 문자열들을 간략하게 저장할 수 있는 자료구조
- 문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료구조임을 미루어 짐작할 수 있다
- 트라이는 트리 형태의 자료구조
- 트리의 루트 노드는 빈 문자열을 나타냄
- 각 노드는 글자 하나를 저장하며, 26개의 자식노드를 가질 수 있다
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열을 나타낸다
  <br><br>

### 질의어 'tree','try','true','toy','wish','win'이 보관된 트라이

- 기본 트라이 자료구조는 노드에 문자들을 저장
- 이용빈도에 따라 정렬된 결과를 내놓기 위해서는 노드에 빈도 정보까지 저장할 필요가 있다

### 트라이도 검색어 자동완성은 어떻게 구현할 수 있을까? ( 가장 많이 사용된 질의어 k개 )

- p: 접두어의 길이, n: 트라이 안에 있는 노드 개수, c: 주어진 노드의 자식 노드 개수
- 해당 접두어를 표현하는 노드를 찾는다
- 해당 노드부터 시작하는 하위트리를 탐색하며 모든 유효 노드를 찾는다. 유효한 검색 문자열을 구성하는 노드가 유효 노드다
- 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다

### 최악의 경우에 전체 트리 다 검색해야하는 경우 해결

- 접두어 최대 길이 제한
  - 사용자가 검색창에 긴 검색어를 입력하는 일은 거의 없다. 따라서 p값은 작은 정수값이라고 가정해도 안전하다
- 노드에 인기 검색어 캐시
  - 각 노드에 k개의 인기 검색어를 저장해 두면 전체 트라이를 검색하는 일을 방지할 수 있다. - 각 노드에 인기 질의어를 캐시하면 top5 검색어를 질의하는 시간 복잡도를 엄청나게 낮출 수 있다.
  - 하지만 각 노드에 질의어를 저장할 공간이 많이 필요하게 된다는 단점도 있다

## (2) 데이터 수집 서비스

- 실시간으로 데이터를 수정하는 서비스는 그닥 실용적이지 못 하다
- 구글 검색 같은 애플리케이션이라면 그렇게 자주 바꿔줄 필요가 없다
- 트라이를 만드는 데 쓰이는 데이터는 보통 데이터 분석 서비스나 로깅 서비스로부터 온다 -> 용례가 달라지더라도 데이터 수집 서비스의 토대는 바뀌지 않을 것

### 데이터 분석 서비스 로그

- 데이터 분석 서비스 로그에는 검색창에 입력된 질의에 관한 원본 데이터가 보관
- 새로운 데이터가 추가될 뿐 수정은 이루어지지 않으며 로그 데이터에는 인덱스를 걸지 않는다

### 로그 취합 서버

- 데이터 분석 서비스로부터 나오는 로그는 보통 양이 엄청나고 데이터 형식도 제각각인 경우가 많다. 따라서 이 데이터를 잘 취합하여 우리 시스템이 쉽게 소비할 수 있도록 해야한다
- 데이터 취합 방식은 우리 서비스의 용례에 따라 달라진다 -> 트위터와 같은 실시간 애플리케이션의 경우 결과를 빨리 보여주는 것이 중요하므로 데이터 취합 주기를 보다 짧게 가져갈 필요가 있다 / 대부분은 일주일에 한 번 정도 로그를 취합해도 충분할 것이다.

### 작업 서버

- 주기적으로 비동기적 작업을 실행하는 서버 집합
- 트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할을 담당한다

### 트라이 캐시

- 분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높이는 구실을 한다
- 매주 트라이 데이터베이스의 스냅샷을 떠서 갱신한다

### 트라이 데이터베이스

- 지속성 저장소
- (1) 문서 저장소 : 새 트라이를 매주 만들 것이므로 주기적으로 트라이를 직렬화하여 데이터베이스에 저장할 수 있다. 몽고디비 같은 문서 저장소를 활용하면 이런 데이터를 편리하게 저장할 수 있다
- (2) 키-값 저장소 : 트라이는 아래 로직을 적용하면 해시 테이블 형태로 변환 가능하다
  - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
  - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환

## (3) 질의 서비스

개략적 설계안에서 살펴본 질의 서비스의 비효율성을 개선한 설계안

1. 검색 질의가 로드밸런서로 전송된다
2. 로드밸런서는 해당 질의를 API 서버로 보낸다
3. API 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다
4. 데이터가 트라이 캐시에 없는 경우에는 데이터를 데이터베이스에서 가져와 캐시에 채운다. 그래야 다음에 같은 접두어에 대한 질의가 오면 캐시에 보관된 데이터를 사용해 처리할 수 있다.( 캐시 미스는 캐시 서버의 메모리가 부족하거나 캐시 서버에 장애가 있어도 발생할 수 있다)

### 질의 서비스 최적화 방안

- AJAX 요청 : 웹 애플리케이션의 경우 브라우저는 보통 AJAX 요청을 보내어 자동완성된 검색어 목록을 가져온다. 장점은 요청을 보내고 받기 위해 페이지를 새로고침 할 필요가 없다는 것
- 브라우저 캐싱 : 대부분 애플리케이션은 자동완성 검색어 제안 결과는 짧은 시간 안에 자주 바뀌지 않는다. 따라서 제안된 검색어들을 브라우저 캐시에 넣어두면 후속 질의의 결과는 해당 캐시에서 바로 가져갈 수 있다.
- 데이터 샘플링 : 대규모 시스템의 경우, 모든 질의 결과를 로깅하도록 해 놓으면 CPU 자원과 저장공간을 엄청나게 소진. N개 요청 가운데 1개만 로깅하도록 하는 데이터 샘플링 기법은 이럴 때 유용

### 트라이 연산

#### 트라이 생성

작업서버가 담당, 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터를 이용한다

#### 트라이 갱신

1. 매주 한 번 갱신하는 방법 -> 새로운 트라이를 만든 다음에 기존 트라이를 대체한다
2. 트라이의 각 노드를 개별적으로 갱신 -> 성능이 좋지 않지만 트라이가 작을 때 고려해봄직 하다

#### 검색어 삭제

- 트라이 캐시 앞에 필터 계층을 두고 부적절한 질의어가 반환되지 않도록 하는 것
- 필터 계층을 두면 필터 규칙에 따라 검색 결과를 자유롭게 변경할 수 있다는 장점
