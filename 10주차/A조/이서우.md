# 13장 검색어 자동 완성 시스템

# 1 단계 문제 이해 및 설계 범위 확정

## 요구사항

- 빠른 응답 속도 : 사용자가 검색어를 입력함에 따라 자동완성 검색어도 충분히 빨리 표시돼야 함
- 연관성: 자동완성되어 출력되는 검색어는 사용자가 입력한 단어와 연관된 것이어야 함
- 정렬 : 결과는 인기도 등의 순위 모델에 의해 정렬돼 있어야 한다
- 규모 확장성 : 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능해야 한다
- 고가용성 : 시스템의 일부에 장애가 발생하거나, 느려지거나 해도 시스템은 계속 사용 가능해야 한다

## 계략적 규모 추정

- 일간 능동 사용자는 천만 명으로 가정
- 평균적으로 한 사용자는 매일 10건의 검색 수행
- 질의할 때마다 평균적으로 20바이트의 데이터를 입력한다고 가정
- 검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다. 따라서 평균적으로 1회 검색당 20건의 요청이 백엔드로 전달된다
- 대략 초당 24000건의 질의(QPS)가 발생, 최대 QPS는 48000
- 질의 가운데 20%정도는 신규 검색어라고 가정. 매일 0.4GB의 신규데이터가 시스템에 추가
  <br><br>

# 2단계 계략적 설게안 제시 및 동의 구하기

개략적으로 보면 시스템은 두 부분으로 나뉜다

- 데이터 수집 서비스(data gathering service) : 사용자가 입력한 질의를 실시간으로 수집하는 시스템
- 질의 서비스(query service): 주어진 질의에 다섯개의 인기 검색어를 정렬해 내놓는 서비스이다

## 데이터 수집 서비스

질의문과 사용빈도를 저장하는 빈도 테이블이 있다고 가정하면 처음에 이 테이블은 비어 있는데 사용자가 단어를 순서대로 검색하면 그 상태가 다음과 같이 바뀌어 나간다

## 질의 서비스

빈도 테이블이 있을때 질의문을 저장하는 필드인 query와 질의문이 사용된 빈도를 저장하는 필드인 frequency가 있다. 사용자가 tw를 검색창에 입력했을때 가장 많이 사용된 5개 검색어는 다음과 같은 SQL 질의문을 이용해 계산할 수 있다

```
SELECT * FROM frequency_table
WHERE query Like `prefix%`
ORDER BY frequency DESC
LIMIT 5
```

데이터 양이 적을 땐 괜찮지만 데이터가 아주 많아지면 데이터베이스가 병목이 될 수 있다
<br><br>

# 3단계 상세 설계

## 트라이 자료구조

- 개략적 설계안에서는 관계형 데이터베이스를 저장소로 사용했지만 이건 효율적이지 않아 트라이를 사용해 이 문제를 해결

### 트라이

- 문자열들을 간략하게 저장할 수 있는 자료구조
- 문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료구조임을 미루어 짐작할 수 있다
- 트라이는 트리 형태의 자료구조
- 트리의 루트 노드는 빈 문자열을 나타냄
- 각 노드는 글자 하나를 저장하며, 26개의 자식노드를 가질 수 있다
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열을 나타낸다
  <br><br>

### 질의어 'tree','try','true','toy','wish','win'이 보관된 트라이

- 기본 트라이 자료구조는 노드에 문자들을 저장
- 이용빈도에 따라 정렬된 결과를 내놓기 위해서는 노드에 빈도 정보까지 저장할 필요가 있다

### 트라이도 검색어 자동완성은 어떻게 구현할 수 있을까? ( 가장 많이 사용된 질의어 k개 )

- p: 접두어의 길이, n: 트라이 안에 있는 노드 개수, c: 주어진 노드의 자식 노드 개수
- 해당 접두어를 표현하는 노드를 찾는다
- 해당 노드부터 시작하는 하위트리를 탐색하며 모든 유효 노드를 찾는다. 유효한 검색 문자열을 구성하는 노드가 유효 노드다
- 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾는다

### 최악의 경우에 전체 트리 다 검색해야하는 경우 해결

- 접두어 최대 길이 제한
  - 사용자가 검색창에 긴 검색어를 입력하는 일은 거의 없다. 따라서 p값은 작은 정수값이라고 가정해도 안전하다
- 노드에 인기 검색어 캐시
  - 각 노드에 k개의 인기 검색어를 저장해 두면 전체 트라이를 검색하는 일을 방지할 수 있다. - 각 노드에 인기 질의어를 캐시하면 top5 검색어를 질의하는 시간 복잡도를 엄청나게 낮출 수 있다.
  - 하지만 각 노드에 질의어를 저장할 공간이 많이 필요하게 된다는 단점도 있다
