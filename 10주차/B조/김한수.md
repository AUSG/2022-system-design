- [검색어 자동완성 시스템](#검색어-자동완성-시스템)
  - [요구사항](#요구사항)
  - [계략적인 설계](#계략적인-설계)
    - [트라이 자료구조](#트라이-자료구조)
    - [조회 연산 최적화하기](#조회-연산-최적화하기)
    - [데이터 수집 서비스](#데이터-수집-서비스)
    - [질의 서비스](#질의-서비스)
    - [검색어 삭제(필터링)](#검색어-삭제필터링)
    - [샤딩?](#샤딩)
  - [Summary](#summary)

# 검색어 자동완성 시스템

검색창에 단어를 입력하다 보면 입력 중인 글자에 맞는 검색어가 자동으로 완성되어 표시되는 것을 볼 수 있다.

이런 기능을 보통 검색어 자동완성(autocomplete, typeahead, search-as-you-type, incremental search)라고 부른다.

이번에는 많이 이용된 검색어 k개를 자동완성하여 출력하는 검색어 자동완성 시스템을 설계해보자

## 요구사항

검색어 자동완성 시스템은 어떤 요구사항들을 만족해야할까?

- 빠른 응답 속도
  - 사용자가 검색어를 입력함에 따라 자동완성 검색어도 충분히 빨리 표시되어야한다. 페이스북 검색어 자동완성 시스템에 관한 문서에 따르면 시스템 응답속도는 100밀리초 이내여야 한다. 그렇지 않으면 UX가 불편해진다.
- 연관성
  - 자동완성 검색어는 사용자가 입력한 단어와 연관된 것이어야 한다.
- 정렬
  - 시스템의 계산 결과는 인기도 등의 순위 모델에 의해 정렬되어야 한다.
- 규모 확장성
  - 많은 트래픽을 감당할 수 있도록 확장 가능해야한다.
- 고가용성
  - 시스템의 일부에 장애가 발생하거나, 느려지거나, 예상치 못한 네트워크 문제가 발생해도 시스템은 계속 사용 가능해야 한다.

## 계략적인 설계

시스템은 다음과 같이 두 부분으로 나뉜다

- 데이터 수집 서비스 (data gathering service)
  - 사용자가 입력한 질의를 실시간으로 수집하는 시스템이다.
  - 데이터가 많은 애플리케이션에 실시간 시스템은 그다지 바람직 하지 않지만 우선 이렇게 출발해서 개선하는 방향으로 해보자.
- 질의 서비스 (query service)
  - 주어진 질의에 다섯 개의 인기 검색어 정렬을 내놓는 서비스

### 트라이 자료구조

RDBMS는 가장 인기있는 다섯 개의 질의문을 골라내는 방안으로 효율적이지 않다.

`트라이`(tire, 혹은 접두어 트리 prefix tree라고도 불림)를 사용해 이를 효율적으로 해결해보자

먼저 트라이에 대해 알아보자

- 트라이는 트리 형태의 자료구조로
- 루트 노드는 빈 문자열을 나타내고
- 알파벳 기준으로 각 노드는 글자(character) 하나를 저장하며, 26개의 자식 노드를 가질 수 있다
(26=해당 글자 다음에 등장할 수 있는 모든 글자의 개수=알파벳수)
- 각 트리 노드는 하나의 단어 또는 접두어 문자열(prefix string)을 나타낸다

위 요구 사항에 따라 각 노드에 글자, 빈도수를 저장한 트리를 나타낸 다음 예시를 살펴보자

![trie-example](https://user-images.githubusercontent.com/72328687/203558784-138a3577-6c60-4b7b-be72-a01f7e3c3a19.png)

조회 시에 시간복잡도도 한 번 대략적으로 구해보자

각 기호를 다음과 같이 정의하고 위 트라이에 가장 많이 사용된 검색어 k개를 찾는다면 다음과 같이 될 것이다

```
p: 접두어(prefix)의 길이
n: 트라이
c: 주어진 노드의 자식 노드 개수
```

- 해당 접두어를 표현하는 노드를 찾는다 ⇒ O(p)
- 찾은 노드부터 시작해 하위 트리를 탐색해 유효한 모든 노드를 찾기 ⇒ O(c)
- 찾은 유효 노드들을 정렬하여 가장 인기있는 검색어 k개 찾기 ⇒ O(clogc)
- 따라서 O(p) + O(c) + O(clogc)

### 조회 연산 최적화하기

위에서 설정한 트라이에서 조회 연산 최적화를 해보자

- `접두어 최대 길이 제한`을 두어 O(상수 시간)으로 해볼 수 있을 것 같다. e.g. 60
  - 사실상 사용자가 엄청 긴 검색어를 입력하는 경우는 거의 없다
- `노드에 인기 검색어 캐시`
  - 최적화 하면 등장하는 캐시.. 여기서도 어김없이 등장한다.
  - 각 노드에 k개의 인기 검색어를 캐싱해두면 전체 트라이를 검색하는 시간을 아껴준다
  - 5~10개 정도의 자동완성 제안을 표시하면 충분할 것 같다.
  - 저장공간이 좀 더 필요하겠지만 빠른 응답속도가 중요하므로 가치가 있는 트레이드오프이다.

    노드에 인기 검색어를 캐시한 모습은 다음과 같이 될 것이다.

    ![trie-node-cache](https://user-images.githubusercontent.com/72328687/203558777-292de642-da5c-43db-89fb-58a7befb9d40.png)

### 데이터 수집 서비스

위에서 살펴본 트라이를 만들기 위해서는 데이터 수집이 필수적이다.

사용자가 타이핑하는 순간순간마다 데이터를 수집하면 방대한 양의 데이터가 쌓일 것이고 매번 트라이를 갱신하면 오히려 성능 저하와 낭비가 될 수 있다.

지금부터 어떻게 하면 데이터 수집을 효율적으로 할 수 있을지에 대해서 알아보자.

- 위에서 눈치챘겠지만 데이터 일정 수준 쌓이면 인기 검색어는 그다지 자주 바뀌지 않으므로 트라이는 자주 갱신할 필요가 없다.
  - 물론 실시간성이 중요한 서비스마다 즉 요구사항에 따라 달라질 순 있겠다.
  - 주기적으로 cronjob과 같은 배치 job을 돌려 트라이를 갱신해야한다.
    일반적으로 일주일 정도의 주기면 적당할 것 같다.
- 데이터 수집 방식
  - 테이터를 수집하는 방식은 여러가지겠지만, 결론적으로 그 데이터를 잘 취합하는 것이 중요하다. 적절한 방식을 선택하자
  - e.g. 로깅 시스템에서 데이터 취합
- 트라이 캐시와 영속성 보장
  - 트라이를 캐시하여 분산 시스템을 구성하여 성능을 높이고
  - 영속성을 위해 DB에 저장해두는 것도 생각볼 수 있다.
  - 여기서 document store(like mongoDB)를 활용하면 성능면에서 적합할 수 있겠다.
  - key-value store도 다음과 같이 활용해볼 수 있겠다.
    - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
    - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환

### 질의 서비스

이제 위에서 설계한 시스템을 기반으로 질의 서비스를 만들면 된다.

자세한 내용은 생략하고 성능면에서 어떤 것들을 개선할 수 있을지만 톺아보자

- 트라이 캐시
  - 캐시를 이용해 디스크 I성능을 개선한다
- 브라우저 캐싱
  - 브라우저 캐시를 사용해 성능을 높인가
  - 대부분 자동완성 검색어 제안 결과는 짧은 시간 안에 자주 바뀌지 않으므로 적합하다
  - e.g. 구글은 브라우저 캐싱을 3600초(1시간)로 설정한다
- 데이터 샘플링(data sampling)
  - 데이터 샘플링 기법은 N개 요청 가운데 1개만 로깅하는 등 로깅하는 수를 줄이는 것이다.
  - 대규모 시스템의 경우, 모든 질의 결과를 로깅하면 CPU 자원과 저장공간을 엄청나게 소모하는데, 이럴 때 적합하다.

### 검색어 삭제(필터링)

비속어가 포함된 질의어는 자동완성 결과에서 제외해야한다.

이럴 때 트라이 캐시 앞 단에 filter layer를 별개로 두어 부적절한 질의어를 반환하지 않게 조정해보자

layer를 별도로 주면 필터 규칙을 수정하기 편리하고 먼저 필터 규칙으로 일시적으로 사용자에게 노출하지 않고, 실제 DB에서 물리적으로 검색어를 삭제하는 것은 비동기적으로 진행하면 된다.

### 샤딩?

데이터가 많아지면 샤딩을 고려해볼 수도 있겠다

데이터가 엄청 많아졌다면 질의어 빈도 수에 따라 적절하게 샤딩을 고려해보자

## Summary

여기까지 검색어 자동완성 시스템 설계하는 법을 간략하게 살펴보았다.

다음 고려사항들이 추가로 인지해두자

- 다국어 지원
  - 트라이에 다국어를 커버할 수 있는 유니코드를 저장한다.
- 국가별로 인기 검색어 순위가 다른 경우
  - 국가별로 다른 트라이를 사용하고 CDN을 이용해 응단속도를 높인다
- 실시간으로 변하는 검색어의 추이를 반영하려면 어떻게 해야할까?
  - 위에서 설계한 새로운 뉴스 이벤트가 생긴다든가 하는 실시간으로 변하는 검색어를 지원하기에 적합하지 않다.
  - 트라이를 구성하는데 너무 많은 시간이 들고, 적절하게 트라이를 갱신해야한다. job을 메뉴얼하게 돌리는 방법으로 가능할 수도 있지만, 100% 자동화는 불가능함.
- 실시간 검색어 자동완성 시스템을 구축하는 것들은 다음 아이디어 정도를 내볼 수 있을 것 같다
  - 샤딩을 통해 작업 대상 데이터의 양을 줄임
  - 순위 모델을 변경하여 최근 검색어보다 높은 가중치를 부여
  - 데이터가 스트림 형태로 올 수 있도록 함.
    - 데이터가 지속적으로 생성되는 스트림 형태기 때문에 한번에 모든 데이터를 동시에 사용할 수 없는 점도 고려해야함.
    - 오픈소스들을 활용 (아파치 하둡 맵리듀스, 아파치 스파크 스트리밍, 아파치 스톰, 아파치 카프카 등)
