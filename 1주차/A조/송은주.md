### 1장: 사용자 수에 따른 규모 확장성

1. 사용자는 도메인 이름 (www.naver.com) 을 이용하여 웹 사이트에 접속
	- 이 접속을 위해서는 도메인 이름을 DNS (도메인 네임 서비스)에 질의하여 **IP 주소로 변환하는 과정이 필요**!
2. DNS 조회 결과로 IP 주소가 반환
3. 해당 IP 주소로 HTTP 요청이 전달
4. 요청받은 웹 서버가 HTML 페이지나 JSON 형태의 응답 반환

**비관계형 데이터베이스가 바람직한 선택인 경우**
1. 아주 낮은 응답 지연시간 요구
2. 다루는 데이터가 비정형인 경우
3. 데이터를 직렬화, 역직렬화할 수 있기만 하면 되는 경우
4. 아주 많은 양의 데이터를 저장할 필요 없는 경우

> ### 수직적 규모 확장 vs 수평적 규모 확장

- 스케일업 Scale Up = 수직적 규모 확장 : 고사양자원 (더 좋은 CPU, 더 많은 RAM) 을 추가
	
    * 장점
    	1. 서버로 유입되는 트래픽 양이 적을 경우 좋은 선택
    * 단점
    	1. 한계가 존재. 한대의 서버에 CPU, 메모리 무한대로 증설할 방법 없음
    	2. 장애에 대한 자동복구(failover), 다중화(redundancy) 방안을 제시하지 않음
           서버에 장애 발생 시 서비스 완전 중단

- 스케일 아웃 Scale Out = 수평적 규모 확장 : 더 많은 서버를 추가하여 성능 개선

_**따라서 대규모 애플리케이션에는 수평적 규모 확장법이 적절함**_

> ### 로드 밸런서

- 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할
- 서버 접속 흐름

	1. 사용자는 로드 밸런서의 공개 IP주소로 접속
	2. 로드밸런서는 웹 서버와 통신하기 위해 같은 네트워크에 속한 서버 사이의 통신에서만 쓰일 수 있는 사설 IP주소를 이용한다
	3. 따라서 웹 서버는 클라이언트의 접속을 직접 처리하지 않게 되며, 더 나은 보안을 유지하게 된다. 

> ### 데이터베이스 다중화

- 주로 서버 사이에 주(Master) - 부(Slave) 관계를 설정하고 데이터 원본을 주 서버에, 사본은 부 서버에 저장하는 방식

  - **쓰기 연산은 Master에서만 지원**

      - 따라서 데이터베이스를 변경하는 insert, delete, update 등은 Master로만 전달되어야 함
  - Slave는 Master로부터 그 사본을 전달받으며, 읽기 연산만을 지원

  → 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높아서, 통상적으로 Slave의 수가 Master 보다 많다

* 데이터베이스를 다중화하면 얻는 이득
  1. 더 나은 성능
      - 주-부 다중화 모델에서는 병렬로 처리될 수 있는 질의(Query)의 수가 늘어나므로 성능이 좋아진다
  2. 안정성 reliability
      - 데이터를 지역적으로 떨어진 여러 장소에 다중화시켜 놓을 수 있다
  3. 가용성 availability
      - 여러 지역에 데이터를 복제해둠으로써, 하나 서버에서 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스할 수 있게 함
      

* 데이터베이스 서버 가운데 하나가 다운되었다면?
	
    - Slave가 1대인데 다운되었다면, 읽기 연산은 한시적으로 모두 Master로 전달. 또한 즉시 Slave가 장애 서버를 대체
    - Master가 다운되면, 1대의 Slave만 있는 경우 해당 Slave가 새로운 Master가 될 것이며, 모든 DB연산은 일시적으로 새로운 Master에서 수행. 그리고 새로운 Slave가 추가됨
    
```
<결론>
1. 사용자는 DNS로부터 로드밸런서의 공개 IP주소를 받음
2. 사용자는 해당 IP주소를 이용해 로드밸런서에 접속
3. HTTP요청은 서버1, 서버2로 전달
4. 웹 서버는 사용자의 데이터를 Slave 서버에서 읽음
5. 웹 서버는 데이터 변경 연산은 Master 로 전달

```
---
> ### 응답시간 완화하기

- 응답시간은 캐시를 붙이고, 정적콘텐츠를 콘텐츠 전송 네트워크(CDN)로 옮기면 개선 가능
- 애플리케이션의 성능은 DB를 얼마나 자주 호출하느냐에 크게 좌우되므로, 캐시를 이용해 성능문제를 완화할 수 있다.
* 캐시 사용 시 유의할 점
	
    - 데이터 **갱신은 자주 일어나지 않지만 참조가 빈번하게 일어난다면** 고려하자!
    - 캐시는 휘발성 메모리이므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않음
    - 캐시에 보관된 **`데이터의 만료 기간 설정`** 필요! 만료정책이 없어도 캐시에 계속 남아있어 문제고, 기한이 너무 짧아도 DB를 너무 자주 읽어서 문제, 너무 길어도 원본과 차이날 가능성 높아짐
    - 데이터 저장소의 원본과 캐시 내의 사본이 같은지 여부를 체크하는 **`일관성을 유지`**하는 것도 중요하다
    - 캐시 서버를 1대만 두면 해당 서버가 단일장애지점이 되어버릴 수 있음
    	- 단일 장애 지점 Single Point of Failure (SPOF) 이란?
        : 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우
        → SPOF 를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야 함
        
   - 캐시메모리가 너무 작으면 데이터가 너무 자주 캐시에서 밀려나버려(eviction) 캐시 성능 저하
   → 이를 막으려면, 캐시메모리를 과할당 (overprovision) 하는 것
   - 데이터 방출 (eviction) 정책이란?
   	- 캐시가 꽉 차서 추가로 데이터를 넣어야할 경우 기존 데이터 내보내야 하는 정책
    	- LRU (Least Recently Used) 정책이 가장 많이 사용됨.


> ### 콘텐츠 전송 네트워크 (CDN)

- **CDN**
	- 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크.
	- 이미지, 비디오, CSS, JS파일 등을 캐시할 수 있음
- CDN의 동작과정
	- 사용자가 웹 사이트 방문하면, 사용자에게 지리적으로 가장 가까운 CDN서버가 정적콘텐츠 전달하게 됨
     1. 사용자가 이미지url을 이용해 png 파일에 접근한다. URL의 도메인은 CDN 서비스 사업자가 제공한 것
     2. CDN 서버 캐시에 해당 이미지가 없으면, 서버는 원본 서버에 요청하여 파일 가져옴
        ex) 원본 서버 : 웹 서버, 아마존 S3
     3. 원본 서버가 파일을 CDN 서버에 반환
     	응답 HTTP 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지 설명하는 TTL값이 있음
     4. CDN 서버는 파일 캐시하고 사용자에게 반환
     5. 또 다른 사용자가 같은 이미지에 대한 요청을 CDN 서버에 전송하면, 만료되지 않은 가정 하에 캐시를 통해 이미지가 처리됨
     
```
<결론>
- 정적 콘텐츠는 더이상 웹서버를 통해 서비스X, CDN을 통해 더 나은 성능보장
- 캐시가 DB부하를 줄여줌
```

> ### 무상태 (stateless) 웹 계층

- 웹 계층을 수평적으로 확장하려면, **사용자 세션데이터와 같은 상태정보를 웹 계층에서 제거**해야 함
- 상태정보를 RDB나 NoSQL 같은 지속성저장소에 보관하고, 필요할 때 가져오도록 하는 것이 가장 바람직함. 
→ 이렇게 구성된 웹 계층을 **무상태 웹 계층**이라고 함

```
ex) 사용자 A의 세션정보나 프로파일 이미지 같은 상태 정보는 서버 1에 저장된다. 
따라서 사용자A를 인증하려면, HTTP 요청이 반드시 서버1로 전송되어야 한다. 
요청이 서버2로 가면 서버2에는 사용자 A의 데이터가 없기에 인증이 실패한다.
```
여기서 문제가 발생) <u>같은 클라이언트로부터 요청이 항상 같은 서버로만 전송되어야 한다.</u>
→ 대부분 로드밸런서가 이를 지원하기 위해 **고정 세션**(Sticky Session) 을 제공하는데, 이는 로드밸런서에 부담을 주며, 서버 장애를 처리하는데 복잡함을 준다.

```
<결론>
웹 서버는 상태정보가 필요할 경우, 공유 저장소로부터 데이터를 가져온다. 
따라서 상태정보는 웹서버로부터 물리적으로 분리되어 있다.
공유 저장소는 RDB일수도, Memcached/Redis 같은 캐시시스템일 수도, NoSQL일 수도 있다.
```

> ### 데이터 센터

- 가용성을 높이고 전세계 어디서도 사용할 수 있도록 하려면 여러 데이터 센터 지원이 필수
- 지리적 라우팅 (geoDNS-routing 또는 geo-routing) : 장애가 없는 상황에서 사용자가 가장 가까운 데이터 센터로 안내되는 것
	- 여기서 geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP주소로 변환할 지 결정하도록 해주는 DNS 서비스이다.

* 다중 데이터센터 아키텍처를 만들기 위해 해결해야 할 기술적 난제
	
    1. 트래픽 우회 
    	- 올바른 데이터센터로 트래픽을 보내는 효과적인 방법을 알아야 한다.
    
    2. 데이터 동기화
    	- 데이터를 여러 데이터 센터에 걸쳐 다중화해야 한다
    3. 테스트와 배포
       
> ### 메세지 큐

**메세지 큐** : 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성인 무손실을 보장하는, `비동기 통신`을 지원하는 컴포넌트
- 메세지 큐를 이용하면 **서비스 또는 서버 간 결합이 느슨해져서** 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.

```
<예시>  
이미지 크롭, 블러링 등을 지원하는 사진 보정 어플에서의 보정은 
시간이 오래 걸릴 수 있는 프로세스이므로 비동기적으로 처리하면 편리하다. 
따라서 보정 작업을 메시지 큐에 넣고, 이 작업을 큐에서 꺼내면서 비동기적으로 완료한다.
```

> ### 로그, 메트릭 그리고 자동화

로그 : 에러 로그를 모니터링하거나 로그를 단일 서비스로 모아주는 도구 활용
메트릭 : 사업 현황에 관한 유용한 정보 얻거나 시스템의 현 상태 파악 가능
자동화 : 지속적 통합을 도와주는 도구 활용

> ### 데이터베이스의 규모 확장

1. 수직적 확장
- 기존 서버에 더 많은, 더 고성능의 자원을 증설하는 방법
	
    - CPU, RAM 등을 무한 증설할 수는 없다.
    - SPOF 로 인한 위험성이 크다
    - 비용이 많이 든다.
    
2. 수평적 확장 (샤딩, Sharding)
- 샤딩: 대규모 DB를 '샤드' 라는 작은 단위로 분할하는 기술
	- 모든 샤드는 **같은 스키마를 쓰지만, 샤드에 보관되는 데이터 사이에는 중복X**
- **`샤딩 키를 어떻게 정하느냐가 가장 중요`**
	샤딩 키는 파티션 키라고도 부르는데, <u>데이터가 어떻게 분산될 지</u> 정하는 하나 이상의 컬럼으로 구성
    → 데이터를 고르게 분할할 수 있도록 샤딩 키를 정해야 함!!

* 샤딩을 도입했을 때 풀어야 할 문제
1. 데이터의 재샤딩(resharding): 데이터가 너무 많아져서 더이상 감당하기 어려울 때, 데이터 분포가 균등하지 못해 공간 소모율이 다를 때
2. 유명인사 문제 (핫스팟 키 문제) : 특정 샤드에 질의ㅈ가 집중되어 서버에 과부하 걸림
3. 조인과 비정규화 : 하나의 DB를 여러 샤드서버로 쪼개고 나면, 여러 샤드에 걸친 데이터 조인이 어려워지므로 DB를 비정규화하거나 하나의 테이블에서 질의 수행되도록 함

> ### 시스템 규모확장을 위해 살펴본 기법 최종 정리

- 웹 계층은 무상태 계층으로 
- 모든 계층에 다중화 도입
- 가능한 많은 데이터 캐시
- 여러 데이터 센터
- 정적콘텐츠는 CDN을 통해
- 데이터 계층은 샤딩으로 규모 확장하기
- 각 계층은 독립서비스로 분할하기
- 지속적인 시스템 모니터링 + 자동화 도구 활용
    