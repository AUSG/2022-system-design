# 사용자 수에 따른 규모 확장성

- 수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, **지속적인 계량과 끝없는 개선이 요구되는 여정**이다.
- 한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계하는 방법에 대해 알아보자.
- [사용자 수에 따른 규모 확장성](#사용자-수에-따른-규모-확장성)
  - [데이터베이스](#데이터베이스)
    - [어떤 데이터베이스를 사용할 것인가?](#어떤-데이터베이스를-사용할-것인가)
  - [수직적 규모 확장 vs 수평적 규모 확장](#수직적-규모-확장-vs-수평적-규모-확장)
  - [로드밸런서](#로드밸런서)
  - [데이터베이스 다중화](#데이터베이스-다중화)
  - [캐시](#캐시)
    - [캐시 계층](#캐시-계층)
    - [캐시 사용 시 유의할 점](#캐시-사용-시-유의할-점)
  - [콘텐츠 전송 네트워크(CDN)](#콘텐츠-전송-네트워크cdn)
    - [CDN 사용 시 고려할 점](#cdn-사용-시-고려할-점)
  - [무상태(stateless) 웹 계층](#무상태stateless-웹-계층)
    - [상태 정보 의존적인 아키텍쳐](#상태-정보-의존적인-아키텍쳐)
    - [무상태 아키텍처](#무상태-아키텍처)
  - [데이터 센터](#데이터-센터)
  - [메시지 큐](#메시지-큐)
  - [로그, 메트릭 그리고 자동화](#로그-메트릭-그리고-자동화)
  - [데이터베이스의 규모 확장](#데이터베이스의-규모-확장)
  - [note. 시스템 규모 확장 기법 정리](#note-시스템-규모-확장-기법-정리)

## 데이터베이스

- 사용자가 늘면 서버 하나로는 충분하지 않아 여러 서버를 두어야한다.
- 하나는 웹/모바일 트래픽 처리 서버(웹 계층), 데이터베이스 서버(데이터 계층)이다.
- 이 계층을 분리하면 각각 독립적으로 확장해 나갈 수 있다.

### 어떤 데이터베이스를 사용할 것인가?

- 기본적으로 과거 오래전부터 쓰인 `관계형 데이터베이스`(Realational database)와 `비-관계형 데이터베이스` 사이에서 고를 수 있다.
- 이 두 데이터베이스는 다음과 같은 차이가 있다.
  - `관계형 데이터베이스`(RDBMS)
    - 관계형 데이터베이스 관리 시스템(RDBMS: Relation Data-base Management System)라고도 부른다.
    - 대표적인 것으로 MySQL, 오라클, PostgreSQL 등이 존재
    - 자료를 테이블과 열, 칼럼으로 표현하며 SQL을 사용하면 여러 테이블에 있는 데이터를 **그 관계에 따라 조인(Join)** 하여 합칠 수 있다.
  - `비 관계형 데이터베이스`(NoSQL)
    - NoSQL이라고도 부른다.
    - 대표적인 것으로 AWS DynamoDB, HBase, Cassandra, Neo4j, CouchDB, MongoDB, Redis 등이 있다.
    - NoSQL은 다음과 같은 네 부류로 나눌 수 있다.
      - `키-캆 저장소(key-value store)`
      - `그래프 저장소(graph store)`
      - `칼럼 저장소(column store)`
      - `문서 저장소(document store)`
    - 비-관계형 데이터베이스는 일반적으로 조인 연산을 지원하지 않는다.
- 대부분의 개발자에게는 RDBMS가 40년 이상 살아남아 잘 사용된 검증된 시스템이라는 점에서 사용하기에 최선일 것이다.
- **하지만 시스템에 따라서 비-관계형 데이터베이스가 더 적합할 수 있다. 이 경우는 다음과 같다**
  - 아주 낮은 응답 지연시간(latency)이 요구됨
  - 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
  - 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
  - 아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 vs 수평적 규모 확장

- `수직적 규모 확장`(vertical scaling)
  - **스케일 업(scale up)** 이라고도 함
  - 서버에 고사양 자원(CPU, RAM 등)을 추가하여 성능을 개선하는 행위
- `수평적 규모 확장`
  - **스케일 아웃(scale out)** 이라고도 함
  - 더 많은 서버를 추가하여 성능을 개선하는 행위
- 서버에 유입되는 트래픽의 양이 적을 때는 `수직적 규모 확장(스케일 업)`이 가장 단순하기에 좋은 선택일 수 있다. 하지만 이는 다음과 같은 한계점, 단점을 가진다
  - 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다
  - 장애에 대한 **자동복구(failover)** 방안이나 **다중화(redundancy)** 방안을 제시하지 않는다.
  - 즉 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다 => **굉장히 치명적**
- `스케일 업`은 위와 같은 단점을 가지기에 대규모 애플리케이션을 지원하는 데는 보통 `스케일 아웃` 방식이 적절하고 이를 위해 로드밸런서를 이용한다

## 로드밸런서

- `로드밸런서`는 **부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.**
- 스케일 아웃 방식을 확장할 때 사용하며 부하 분산 집합에 또 하나의 웹 서버를 추가하면 장애를 자동복구하지 못하는 **no failover 문제를 해소**하며 **웹 계층의 가용성(availability)을 향상**시킨다.
- 로드밸런서 + health check를 이용해 서버 장애 상태에 따라 오토스케일링 등을 통해 유연한 확장 및 장애 복구를 할 수도 있다.

## 데이터베이스 다중화

- 많은 데이터베이스 관리 시스템은 다중화를 지원하며 보통 서버 사이에 **주(master)-부(slave)관계**를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다. (slave를 read replica라고도 표현한다)
- **쓰기 연산(write operation)은 master에서만 지원하며, slave는 master로부터 해당 데이터 사본을 전달받게 되고 읽기 연산(read operation)만을 지원한다.**
- 대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높아 slave 수가 master보다 많다.
- 데이터베이스를 다중화 하게 되면 다음과 같은 이점이 있다
  - `처리 성능 향상`: 읽기 연산은 slave 데이터베이스들로 분산되므로 병렬로 처리될 수 있는 질의(query)의 수가 늘어나 전체적인 처리 성능이 좋아진다.
  - `안정성(reliability)`: 데이터를 지역적으로 떨어진 여러 장소에 다중화 시켜두면 자연 재해 등으로 데이터베이스 서버 일부가 파괴되어도 데이터는 보존된다.
  - `가용성(availability)`: 데이터를 여러 지역에 복제해 둠으로써 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스를 할 수 있게 된다.
- 이와 관련해서 특정 데이터베이스가 다운되는 경우 다음과 같은 상황들이 있을 수 있다.
  - slave가 하나인 상태에서 해당 slave가 다운된 경우, 읽기 연산은 한시적으로 모두 master로 전달된다. slave가 여러 개인 상황에서는 장애가 발생하지 않은 다른 slave로 읽기 연산이 전달된다.
  - master가 다운된 경우, slave 중 하나가 master가 되며 기존에 빈 자리를 채우기 위해 새로운 slave가 하나 추가된다.
  - 운영 환경에서는 더 복잡한 일들이 벌어지는데, master에 저장된 데이터가 최신 상태가 아닐 수 있고 이를 위해 없는 데이터를 **복구 스크립트(recovery script)**를 돌려 추가하거나 **다중 마스터(multi-masters)** 나 **원형 다중화(circular replication)** 방식을 도입하면 이런 상황에 대처하는 데 도움이 될 수도 있다. 하지만 해당 구성은 훨씬 복잡하며 실제 운영에서는 각 상황에 맞게 트레이드오프를 고려해야만 한다.

## 캐시

- 캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소로 사용된다.
- 애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 영향을 받는데, 캐시는 이 문제를 완화할 수 있다.

### 캐시 계층

- 캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.
- 따라서 별도의 캐시 계층을 두면 성능이 개선될 뿐만 아니라 데이터베이스의 부하를 줄일 수 있고, 캐시 계층의 규모를 독립적으로 확장시키는 것도 가능하다.
- 캐싱에는 다양한 전략들이 존재하며, 캐시할 데이터의 종류, 크기, 데이터 접근 패턴에 맞는 각 캐시 전략을 잘 조합하여 선택해야한다
- 예시로 다음과 같은 전략들이 존재한다.
  - `Look-Aside 읽기 전략(=Lazy Loading)`
    - 캐시에 데이터가 없으면 DB에서 데이터를 조회하고 이를 캐시에도 추가한다.
    - 찾는 데이터가 없을 때 DB에서 직접 조회해서 입력하기 때문에 Lazy Loading이라고 한다.
    - 데이터가 없을 시 connection을 3번(Cache Hit, DB Read, Cache Write)해야한다
    - 대부분의 상황에서 사용되며 굉장히 쉽다
  - `Read-Through 읽기 전략`
    - 데이터를 읽을 때 캐시로만 데이터를 읽어오고 Cache Miss가 발생하면 DB에서 해당 데이터를 캐시에 바로 저장한다.
    - Look-Aside는 Cache Miss가 발생하면 앱이 직접 DB에 데이터를 조회하는 반면, Read-Through은 앱이 아닌 캐시에서 DB에 데이터를 직접 조회하여 로드한다.
    - 동일한 데이터가 여러번 읽기 요청 되는 경우에 적합하다
  - `Write-Through 쓰기 전략`
    - 캐시에서만 데이터를 조회하고 DB에서 update, create가 발생했을 때 해당 데이터를 cache에 저장한다.
    - DB에 데이터 추가 → cache sync 과정에서 sync 이전에 데이터를 조회하는 경우가 있을 수 있다 (=데이터 유실) 그래서 보통 Lazy Loading 전략과 결합하여 사용한다.
    - 많은 데이터를 저장해 일부 데이터가 읽히지 않는 경우 리소스 손실이 발생한다. 따라서 캐시 무표화를 위해 캐시 만료 시간인 `TTL`(Time To Leave)를 설정해주는 것이 좋다
    - Raed-Through 읽기 전략과 함께 사용하면 Read-Through의 모든 이점을 얻을 수 있고 데이터 일관성도 보장되어 캐시 무효화를 사용하지 않아도 된다.

### 캐시 사용 시 유의할 점

캐시 사용 시에는 다음 사항들을 고려해야 한다.

- **캐시는 어떤 상황에서 바람직한가?**
  - 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼만하다.
- **어떤 데이터를 캐시에 두어야하는가?**
  - 휘발성 메모리에 캐시를 두므로 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
- **캐시에 보관된 데이터는 어떻게 만료(expire)되는가?**
  - 이에 대한 정책을 마련해두는 것은 굉장히 중요하다.
  - 만료 정책이 없으면 데이터는 캐시에 계속 남게되고 만료 시간을 너무 짧게 잡거나 너무 길게 잡으면 데이터베이스 연산을 너무 자주하거나 최신의 데이터가 아닐 가능성이 높다(=원본 데이터와 차이 발생)
- **일관성(consistency)은 어떻게 유지되는가?**
  - 일관성은 데이터 저장소의 원본과 캐시 내의 사본이 같은지 여부이다.
  - 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 이 일관성은 깨질 수 있다. 여러 지역에 걸쳐 시스템을 확장하는 경우에는 캐시와 저장소 사이의 일관성을 유지하는 것은 더더욱 어려운 문제가 된다.
- **장애에는 어떻게 대처할 것인가?**
  - 캐시 서버를 한 대만 두는 경우 해당 서버는 전체 시스템의 동작을 중단시켜 버릴 수 있는 단일 장애 지점(SPOF: Single Point Of Failure)이 되어버릴 가능성이 있다. 
  - 따라서 캐시 서버도 여러 지역에 걸쳐 분산시켜야한다.
- **캐시 메모리는 얼마나 크게 잡을 것인가?**
  - 캐시 메모리가 너무 작으면 데이터 접근 패턴에 따라 데이터가 너무 자주 캐시에서 밀려나버려(eviction) 캐시의 성능이 떨어진다.
  - 이를 막을 한 가지 방법은 **캐시 메모리를 과할당(overprovision)** 하는 것이다. 이렇게 하면 캐시에 보관될 데이터가 갑자기 늘어났을 때 생길 문제도 방지할 수 있게 된다.
- **데이터 방출(eviction) 정책은 무엇인가?**
  - 캐시가 꽉 차버리면 추가로 캐시에 데이터를 넣어야 할 경우 기존 데이터를 내보내야(`eviction`) 한다.
  - 캐시 데이터 방출 정책에는 다음과 같은 정책들이 있으며 경우에 맞게 적용 가능하다.
  - `LRU`(Least Recently Used - 마지막으로 사용된 시점이 가장 오래된 데이터를 내보냄) -> **가장 널리 쓰임**
  - `LFU`(Least Frequently Used - 사용 빈도가 가장 낮은 데이터를 내보냄)
  - `FIFO`(First In First Out - 선입선출)

## 콘텐츠 전송 네트워크(CDN)

- `CDN`은 **정적 콘텐츠(JS, CSS, 이미지 등)를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다.**
- 어떤 사용자가 웹사이트에 방문하면 해당 사용자와 지리적으로 가까운 CDN 서버가 정적 콘텐츠를 전달하게 된다. 이는 지리적으로 가까우므로 로드 시간에 이점을 가진다
- 오청 경로, query string, 쿠키, 요청 헤더 등의 정보에 기반하여 HTML을 캐싱하는 동적 콘텐츠를 캐싱하는 것도 가능한데 이는 [AWS CloudFront 동적 콘텐츠 전송](https://aws.amazon.com/ko/cloudfront/dynamic-content/)문서를 살펴보자.

### CDN 사용 시 고려할 점

- **비용**: CDN은 보통 제3 사업자(third-party providers)에 의해 운영되므로 해당 데이터 전송 양에 따라 요금이 발생한다. 자주 사용되지 않는 컨텐츠를 캐싱하는 것은 이득이 크지 않으므로, CDN에서 빼는 것을 고려하자.
- **적절한 만료 시한 설정**: 시의성이 중요한(time-sensitive) 컨텐츠의 경우 만료 시점을 적절히 설정해야한다. 너무 길면 컨텐츠의 신선도가 떨어지고, 너무 짧으면 원본 서버에 빈번히 접속하게 된다.
- **CDN 장애에 대한 대처 방안**: CDN 자체에 장애가 발생했을 경우 웹사이트/애플리케이션이 어떻게 동작해야 하는지 고려해야한다. 가량 일시적으로 CDN이 응답하지 않을 경우, 해당 문제를 감지하여 원본 서버로부터 직접 컨텐츠를 가져오도록 클라이언트를 구성하는 것이 필요할 수 있다.
- **컨텐츠 무효화(invalidation) 방법**: 아직 만료되지 않은 컨텐츠라 하더라도 아래 방법 가운데 하나를 사용하면 CDN에서 제거할 수 있다.
  - CDN 서비스 사업자가 제공하는 API를 이용해 컨텐츠 무효화
  - 컨텐츠의 다른 버전을 서비스하도록 `오브젝트 버저닝(object versioning)`을 이용. 컨텐츠의 새로운 버전을 지정하기 위해서는 URL 마지막에 버전 번호를 인자로 주면 된다. e.g. image.png?v=3

## 무상태(stateless) 웹 계층

- 웹 계층을 수평적으로 확장하는 방법을 알아보자.
- 이를 위해서는 상태 정보(사용자 세션 데이터 등)를 웹 계층에서 제거하여 의존성을 제거해야한다.
- 바람직한 전략은 상태 정보를 지속성 저장소(관계형 DB나 NoSQL)에 보관하고, 필요할 때 조회하는 것이다.
- 상태 정보를 제거하여 이렇게 구성된 웹 계층을 `무상태 웹 계층`이라고 부른다.

### 상태 정보 의존적인 아키텍쳐

- 사용자 A의 상태 정보(세선 정보, 프로필 이미지 등)가 서버 1에 저장되어 있다면 사용자 A의 요청은 반드시 서버 1에 저장되어야 한다. 그렇지 않고 서버 2에 저장되면 이미 인증을 하여 세션에 인증 정보가 서버 1에 저장된 상황에서 서버 2에는 인증 정보가 없기 때문에 인증이 실패하게 된다.
- 스케일 아웃 환경에서 이런 경우를 방지하기 위해 대부분의 로드밸런서는 `고정 세션`(sticky session) 기능을 제공하고 있는데, 이는 로드밸런서에 부담을 주고 로드밸런서 뒷단에 서버를 추가하거나 제거하기가 까다로워지며 서버의 장애를 처리하기도 복잡해지는 단점이 있다.

### 무상태 아키텍처

- 위와같은 상태 정보 의존적 아키텍처에서 상태 정보를 **공유 저장소(shared storage)** 로부터 가져오게 함으로써 `무상태 아키텍처`를 구성할 수 있다.
- `공유 저장소`는 RDBMS나 Memcached/Redis 같은 캐시 시스템 혹은 NoSQL일 수도 있다.
- 이렇게 하면 상태 정보가 웹 서버들로부터 제거되었으므로 트래픽 양에 따라 웹 서버를 추가하거나 제거하면 자동으로 규모를 확장할 수 있게 된다.

## 데이터 센터

- 가용성을 높이고 전 세계 어디서도 쾌적하게 사용할 수 있도록 하기 위해 여러 데이터 센터를 지원해야할 수도 있다.
- 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 이를 `지리적 라우팅`(geoDNS-routing or geo-routing)이라고 부른다.
- `geoDNS`는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스이다. 일정 가중치를 두어 어떤 데이터센터에 지리적 위치 기준으로 몇 %의 사용자를 안내할지 결정할 수도 있다.
- 다중 데이터센터 아키텍처를 만드려면 다음과 같은 기술적 난제를 해결해야한다.
  - **트래픽 우회**
    - 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 한다. GeoDNS는 사용자에게서 가장 가까운 데이터센터로 트래픽을 보낼 수 있도록 해준다.
  - **데이터 동기화(synchronization)** 
    - 데이터 센터마다 별도의 데이터베이스를 사용하고 있는 상황이라면 failover해서 트래픽이 다른 데이터베이스로 우회한다고 해도 해당 데이터센터에는 찾는 데이터가 없을 수 있다.
    - 이런 상황을 막는 보편적 전략은 데이터를 여러 데이터 센터에 걸쳐 다중화 하는 것이다.
  - **테스트와 배포(deployment)**
    - 여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 여러 위치에서 테스트해보는 것이 중요하다. 그리고 자동화된 배포 도구는 모든 데이터 센터에 동일하게 서비스가 설치되도록 하는 데 중요한 역할을 한다.

## 메시지 큐

**시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있도록 해야한다.** `메시지 큐(message queue)`는 많은 실제 분산 시스템에서 이 문제를 풀기 위해 사용하는 핵심적인 전략 중 하나이다.

- 메시지 큐는 메시지의 `무손실`(durability, 메시지 큐에 보관된 메시지는 소비자가 꺼낼 때까지 안전하게 보관됨)을 보장하고 `비동기 통신`을 지원하는 컴포넌트이며 메시지의 버퍼 역할을 하고 이를 비동기적으로 전송한다.
- 메시지 큐의 기본 아키텍처는 다음과 같다.
  - **생산자 또는 발행자**(producer/publisher)라고 불리는 입력 서비스가 **메시지를 생성하여 메시지 큐에 발행**(publish)
  - **소비자 혹은 구독자**(consumer/subscriber)라고 불리는 서비스 혹은 서버가 **메시지를 받아 그에 맞는 동작을 수행**
- 메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져 규모 확장성이 보장되어야 하는 안정적인 애플리케이션을 구성하기 좋다.
- 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있고, 소비자는 생상자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.

## 로그, 메트릭 그리고 자동화

소규모일 때는 로그, 메트릭(metric) 그리고 자동화(automation)가 있으면 좋지만 트레이드오프를 고려해 챙기지 못할 수 있다. 하지만 웹 사이트와 사업 규모가 커지고 나면, 필연적으로 이에 투자해야한다.

- **로그**
  - 에러 로그를 모니터링하는 것은 시스템의 오류와 문제들을 보다 쉽게 찾아낼 수 있기에 중요하다.
  - 에러 로그는 서버 단위로 모니터링 할 수도 있지만, 단일 서비스에 로그를 모아주는 도구를 활용하면 좀 더 편리하게 검색하고 조회할 수 있다.
- **메트릭(metric)**
  - 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 얻을 수도 있고, 시스템의 현재 상태를 손쉽게 파악할 수도 있다. 메트릭 가운데 특히 유용한 것들은 다음과 같다.
    - **호스트 단위 메트릭**: CPU, 메모리, 디스크 I/O에 관한 메트릭
    - **종합(aggregated) 메트릭**: 데이터베이스 계층의 성능, 캐시 계층의 성능
    - **핵심 비즈니스 메트릭**: 일별 능동 사용자(DAU: Daily Active User), 수익(Revenue), 재방문(Retention)
- **자동화(automation)**
  - 시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 활용해야 한다.
  - 지속적 통합(CI: Continuous Integration)도구를 이용하면 개발자가 만드는 코드를 특정 검증 절차를 자동으로 거치도록하여 문제를 쉽게 감지할 수도 있고
  - 빌드, 테스트, 배포 등의 절차도 자동화하여 개발 생산성을 크게 향상시킬 수 있다.

## 데이터베이스의 규모 확장

저장할 데이터가 많아지면 DB에도 부하가 증가하고, DB를 증설할 방법을 찾아야한다.

- 데이터베이스 규모 확장에는 `수직적 규모 확장(스케일 업)`, `수평적 규모 확장(스케일 아웃, 샤딩)` 이렇게 두 가지 접근법이 있다.
- `수직적 확장(스케일 업)`
  - 기존 서버에 고성능의 자원을 증설하는 방법이다.(CPU, RAM, 디스크 등)
  - AWS RDS는 24TB RAM을 갖춘 서버도 상품으로 제공하고 있다고 한다. 이 정도 수준의 고성능 데이터베이스 서버는 많은 양의 데이터를 보관하고 처리할 수 있다.
  - 예를 들어 스택오버플로(stackoverflow.com)는 2013년 한 해 동안 방문한 천만 명의 사용자 전부를 단 한대의 마스터 데이터베이스로 처리하였다.
  - 하지만 이러한 수직적 접근법에는 몇가지 심각한 약점이 있다.
    - **데이터베이스 서버 하드웨어에 한계가 있으므로 무한 증설이 불가능하다. 사용자가 늘어나면 결국에는 한 대 서버로는 감당하기 힘들다.**
    - **SPOF(Single Point Of Failure)로 인한 위험성이 크다.**
    - **고성능 서버 사용으로 인한 서버 비용이 많이 든다.**
- `수평적 확장(스케일 아웃, 샤딩)`
  - **샤딩(sharding)** 이라고도 부르며 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있다.
  - `샤딩`은 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술이다.
  - 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.
  - e.g. 예를 들어 4개의 샤드가 있다면 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 결정된다고 했을 때, `user_id % 4` 등의 연산을 통해 어떤 샤드에 해당 데이터를 저장할지 결정할 수 있다.
  - `샤딩 키(sharding key)`
    - 샤딩 전략을 구현할 때 고려해야할 가장 중요한 것은 **샤딩 키(sharding key)를 어떻게 정하느냐**이다. 이는 파티션 키(partition key)라고도 부른다.
    - 샤딩 키는 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성되며 예를 들면 user_id가 될 수도 있다.
    - 샤딩 키를 정할 때는 데이터가 고르게 분산될 수 있도록 하는 게 가장 중요하다.
  - **샤딩은 데이터베이스 규모 확장을 실현하는 훌륭한 기술이지만 완벽하진 않다. 샤딩을 도입하면 시스템이 복잡해지고 풀어야 할 새로운 문제도 생긴다.**
    - `데이터 재 샤딩(resharding)`
      - 다음과 같은 특정 경우에 재 샤딩이 필요한 경우가 생길 수 있다.
        - 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어렵거나
        - 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때. **샤드 소진(shard exhaustion)** 이라고도 부르는 이 현상이 발생했을 경우
    - `유명인사(celebrity) 문제`
      - `핫스팟 키(hotspot key)`문제라고도 부름
      - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제 e.g. 유명인사(연예인, 인플루언서 등)가 전부 같은 샤드에 저장되는 데이터베이스가 있다면 이 데이터베이스에 read 연산량이 많아서 과부하가 걸릴 수 있다.
      - 이 문제를 풀려면 경우에 따라 나열한 유명인사 각각에 샤드 하나씩을 할당해야 할 수도 있고, 심지어는 더 잘게 쪼개야 할 수도 있다.
    - `조인과 비정규화(join and de-normalization`
      - 하나의 데이터베이스를 여러 샤드로 쪼개고 나면 여러 샤드에 걸친 데이터를 조인하기 힘들어진다. 이를 해결하는 방법은 데이터베이스를 정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.

## note. 시스템 규모 확장 기법 정리

- 웹 계층을 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독릭접 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
