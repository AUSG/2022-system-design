# 1장 사용자 수에 따른 규모 확장성

## 1. 단일 서버

### 단일 서버를 이용하여 사용자가 요청을 처리하는 순서

- 사용자가 알고 있는 도메인 이름을 도메인 이름 서비스 ( DNS ) 에 질의한다.
- DNS 로부터 IP 주소를 받는다.
- 해당 IP 주소로 HTTP 요청이 전달된다.
- 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태로 응답을 반환한다.
- 이 때 요청은 웹 애플리케이션 혹은 모바일 앱 두 가지의 단말로부터 전송된다.

## 2. 데이터베이스

서버 하나로는 충분하지 않을 경우 **웹/모바일 트래픽 처리 서버 (웹 계층)** 과 **데이터베이스 서버(데이터 계층)**을 분리하면 그들을 독립적으로 확장할 수 있게 된다.

### 어떠한 데이터베이스를 사용할 것인가?

- **관계형 데이터베이스**
    - 관계형 데이터베이스 관리 시스템 (RDBMS) 라고도 부르는데, 대표적으로 MySQL, 오라클 데이터베이스, PostgreSQL 등이 있다. 자료를 열과 컬럼으로 표편하고 테이블을 join 하여 합칠 수 있다.
- **비관계형 데이터베이스**
    - NoSQL 이라고도 부르며 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소 네 분류로 나뉜다.
    - 다음의 경우 비관계형 데이터베이스를 사용하는 것이 바람직할 수 있다.
        - 아주 낮은 latency를 요구하는경우
        - 데이터가 비정형인 경우
        - 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면 될 때
        - 아주 많은 양의 데이터를 저장할 필요가 있을 때

## 3. 수직적 확장 vs 수평적 확장

- **수직적 확장 (scale up)**
    - 서버에 고사양 자원 ( CPU 자원 향상, RAM 추가 ) 을 추가하는 행위.
    - 한계점
        - 한 대의 서버에 CPU, 메모리를 무한으로 확장할 수 없어 규모 확장에 한계가 있다.
        - 장애에 대한 자동복구 (failover) 방안이나 다중화 (redundancy) 방안을 제시하지 않아 서비스가 완전히 중단된다.
- **수평적 확장 (scale out)**
    - 더 많은 서버를 추가하여 성능 개선.

**→ 대규모 트래픽을 처리하는 데이 있어서 수평적 확장이 더 적절.**

### 로드밸런서

부하 분산 집합 (load balancing set) 에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다. 사용자는 로드밸런서의 공개 IP 주소로 접속하게 되고 서버 간 통신은 사설 IP 주소를 통해 이루어진다. 작동 방식을 더 자세히 정리하면 다음과 같다.

- 서버 1이 다운되면 서버 2로 모든 트래픽이 전송된다.
- 트래픽이 가파르게 증가하더라도 서버를 더 추가하면 로드밸런서가 자동적으로 트래픽을 분산한다.

**→ no failover 문제를 해결해주고 가용성이 향상된다.**

### 데이터베이스 다중화

주 (master) - 부 (slave) 데이터베이서 서버를 설정하여 원본은 주 서버에, 사본은 부 서버에 저장.

이 때, write는 주 서버에서만, read는 부 서버에서만 지원한다.

- 성능 개선
    - 병렬 처리할 수 있는 query 가 늘어남.
- 안정성
    - 데이터베이스 서버를 지역적으로 여러 곳에 다중화시켜 서버 파괴 시에도 데이터 보존.
- 가용성
    - 데이터를 여러 지역에 복제해두어 장애에 대비함.
    

다음은 로드밸런서와 데이터베이스 다중화를 고려한 설계안이다.

- 사용자는 DNS로부터 로드밸런서의 IP 주소를 받음
- 로드밸런서에 접속하고, HTTP 요청이 서버1 혹은 2로 전달됨.
- 웹 서버는 부 데이터베이스 서버에서 데이터를 읽음.
- 데이터 변경 연산은 주 데이터베이스로 전달됨.

## 4. 캐시

캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두어 해당 요청이 빨리 처리될 수 있도록 하는 저장소이다.

### 캐시 계층

데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빨라 성능을 개선시킬 수 있다. 또한 데이터베이스의 부하를 줄이고 캐시 계층 규모를 독립적으로 확장시킬 수 있다.

- **주도형 캐시 전략** : 요청을 받은 서버가 캐시에 응답이 저장되어 있는지 보고 그렇지 않은 경우 데이터베이스에 질의를 하여 데이터를 캐시에 저장한 뒤 클라이언트에 반환하는 방법.

### 캐시 사용 시 유의할 점

- 데이터 갱신이 자주 일어나지 않지만 **참조가 빈번하게 일어날 때** 유용하다.
- 캐시는 데이터를 휘발성 메모리에 두므로, **영구 보관할 데이터는 지속적 저장소에 저장**해야 한다.
- 캐시에 보관된 데이터에 대한 **만료 정책을 마련**하는게 좋다. 만료 기간이 너무 짧으면 데이터베이스를 너무 자주 읽게 되므로 좋지 않고, 너무 길게 되면 원본이랑 차이가 날 가능성이 높으므로 주의해야 한다.
- **일관성**. 데이터 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜젝션이 아닌 경우 문제가 된다.
- 여러 지역에 걸쳐 **캐시 서버를 분산**시켜 SPOF 를 방지한다.
- **캐시 메모리 크기**. 크기가 너무 작은 경우 데이터가 너무 자주 밀려나는 (eviction) 현상이 발생하여 성능이 떨어진다. 캐시 메모리를 과할당 (overprovision) 하여 캐시 메모리에 데이터가 급격히 늘어나는 현상을 대비한다.
- **데이터 방출 (eviction) 정책**. LRU (Least Recently Used), LFU (Least Frequently Used), FIFO (First In First Out) 중에서 적절한 정책을 사용한다.

## 5. 콘텐츠 전송 네트워크 (CDN)

CDN은 정적 콘텐츠를 전송할 때 쓰이는 분산된 서버의 네트워크이다. 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.

**→ 사이트 로딩 시간을 개선하는 데에 사용된다.**

### CDN 동작 방식

- 사용자가 이미지 URL을 통해 image.png에 접근.
- CDN 서버의 캐시에 해당 이미지가 없는 경우, 원본 서버에서 가져옴. 원본 서버는 웹 서버일 수도 있고 S3와 같은 온라인 저장소일 수도 있다.
- 원본 서버가 파일을 CDN 서버에 저장. 응답의 HTTP 헤더에는 TTL (Time to Live) 값이 들어있음.
- CDN 서버는 파일을 캐시하고 사용자에게 반환. 해당 이미지는 TTL 만큼 캐시됨.
- 이후 다른 사용자가 CDN 서버에 같은 이미지에 대한 요청을 전송하면 캐시를 통해 처리.

### CDN 사용 시 고려해야 할 사항

- 비용
    - CDN은 보통 third-party 제공자에 의해 운영되고, CDN으로 들어가고 나가는 데이터 양에 따라 요금이 부과되므로 자주 사용되지 않는 콘텐츠는 캐싱하지 말자.
- 적절한 만료 시한 설정
    - time-sensitive 한 데이터의 경우 만료 시한이 너무 길면 데이터의 신선도가 떨어지고, 너무 짧으면 원본 서버에 빈번히 접속해야 한다.
- CDN 장애에 대한 대처 방안
    - CDN 이 일시적으로 동작하지 않을 경우, 해당 문제를 감지하여 원본 서버에 직접 접속하는 등의 클라이언트 구성이 필요하다.
- 콘텐츠 무효화 (invalidation) 방법
    - 아직 만료되지 않은 콘텐츠라도 아래의 방법으로 CDN에서 제거할 수 있다.
        - CDN 서비스 사업자가 제공하는 API를 이용하여 콘텐츠 무효화
        - 콘텐스의 다른 버전을 서비스하도록 오브젝트 버저닝 (object versioning) 이용. image.png?v=2 와 같이 새로운 버전을 지정.
        

## 6. 무상태 (stateless) 웹 계층

웹 계층을 수평적으로 확장하려면 **상태 정보 (사용자 세션 데이터 등) 를 웹 계층에서 제거**해야 한다.  상태 정보는 관계형 데이터베이스나 NoSQL 과 같은 **지속적 저장소에 저장**하여 필요할 때 가져오면 되는데, 이렇게 구성된 것을 무상태 웹 계층이라고 한다.

### 상태 정보 의존적인 아키텍처

- 서버는 상태를 유지하여 요청들 사이에서 공유되도록 함.
- 클라이언트로부터 항상 같은 서버로 요청을 보내야 함.
- 로드밸런서는 고정 세션 (sticky-session)  기능을 제공할 수 있으나 부담이 됨.
- 로드밸런서 뒷단에 서버 추가 및 제거도 까다로움.

### 무상태 아키텍처

- HTTP 요청이 어떤 웹 서버로도 전달 가능.
- 상태 정보가 필요할 경우 웹 서버는 공유 저장소 (shared storage) 로부터 데이터를 가져옴.
- Memcached/Redis 와 같은 캐시 시스템이 적용될 수도 있고, NoSQL을 이용할 경우 규모 확장이 간편해진다.
- 상태 정보 제거에 따라 자동 규모 확장 (autoscaling) 이 가능해진다.

## 7. 데이터 센터

- 지리적 라우팅 (geoDNS-routing, geo-routing)
    - 장애가 없는 상황에서 사용자가 가장 가까운 데이터 센터로 안내되는 절차
- 데이터 센터 중 하나에 심각한 장애가 발생한 경우 모든 트래픽은 장애 없는 데이터 센터로 전송된다.
- 다중 데이터센터 아키텍처를 만들 때 고려할 점
    - 트래픽 우회
    - 데이터 동기화 (synchronization)
        - 데이터 센터마다 별도의 데이터베이스를 사용하는 경우 장애가 자동으로 복구 (failover)되어도 해당 데이터 센터에 원하는 데이터가 없을 수 있다.
    - 테스트와 배포
        - 여러 데이터 센터를 이용하도록 설계되었다면 서비스를 여러 위치에서 테스트해보는 것이 중요하다.
        - 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 한다.

## 8. 메시지 큐

메시지 큐는 **메시지의 무손실 (durability)** 을 보장하는 컴포넌트이다. **메시지의 버퍼** 역할을 하며 **비동기 통신**을 지원한다.

- 메시지 큐의 기본 아키텍처
    - 생산자 또는 발생자 (producer/publisher) 라고 불리는 입력 서비스가 메시지를 만들어 큐에 발행 (publish) 한다.
    - 큐에는 소비자 혹은 구독자 (consumer/subscriber) 라고 불리는 서비스 혹은 서버가 연결되어 있는데, 메시지를 받아 그에 맞는 역할을 수행한다.
    
    → 서비스 또는 서버 간 결합이 느슨해져서 규모 확장성을 보장할 수 있으므로 안정적인 어플리케이션을 구성하기 좋다.
    
- 사용 예시
    - 사진 보정 어플리케이션. 사진 보정 작업 프로세스들이 작업을 메시지 큐에서 꺼내어 비동기적으로 완료한다.
    

## 9. 로그, 메트릭 그리고 자동화

- **로그**
    - 에러 로그는 서버 단위로 모니터링 할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다.
- **메트릭**
    - 호스트 단위 메트릭 : CPU, 메모리, 디스크 I/O 에 관한 메트릭
    - 종합 (aggregated) 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능 같은 것
    - 핵심 비즈니스 메트릭 : 일별 능동 사용자, 재방문 같은 것
- **자동화**
    - 시스템이 복잡해지면 생산성을 높이기 위해 자동화 도구를 사용.
    - 지속적 통합 (continuous integration) 을 도와주는 도구를 활용하면 검증 절차를 자동으로 실행하여 문제를 쉽게 감지할 수 있다.
    - 빌드, 테스트 배포 등의 절차를 자동화하여 생산성 향상.

 

## 10. 데이터베이스의 규모 확장

- **수직적 확장 (scale up)**
    - 기존 서버에 더 많은, 또는 고성능의 자원을 증설하는 방법.
    - 약점
        - 데이터베이스 서버 하드웨어는 한계가 있어서 CPU, RAM 등을 무한으로 증설할 수 없다.
        - SPOF 위험성이 크다.
        - 비용이 많이 든다. 고성능 서버로 갈수록 비용이 커진다.
- **수평적 확장 (sharding)**
    - 대규모 데이터베이스를 샤드 (shard) 라고 부르는 작은 단위로 분할하는 기술.
    - 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.
    - 샤딩 키를 정하는 전략을 잘 마련하는 것이 중요하다.
    - 샤딩에서 발생할 수 있는 문제
        - 데이터의 재 샤딩 (resharding)
            - 데이터가 너무 많아져서 하나의 샤드로 감당할 수 없거나, 샤드 간 데이터 분포가 균등하지 못하여 공간이 소모되어 샤드 소진 (shard exhaustion) 이 발생할 수 있음.
            - 샤드 키 계산 함수를 변경하고 뎅터를 재비치하여야.
            - 안정 해시 (consistent hash) 기법으로 해결 가능.
        - 유명인사 (celebrity) 문제
            - 핫 스팟 키 (hotspot key) 문제. 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제.
            - 유명인사 각각에 샤드를 하나씩 할당하거나 더 잘게 쪼개야 할 수도.
        - 조인과 비정규화 (join and de-nomarlization)
            - 하나의 데이터베이스를 여러 샤드로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다.
            - 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 할 수 있다.
            
    
    ## 11. 시스템 규모 확장 기법 정리
    
    - 웹 계층은 무상태 계층으로
    - 모든 계층에 다중화 도입
    - 가능한 한 많은 데이터를 캐시할 것
    - 여러 데이터 센터를 지원할 것
    - 정적 콘텐츠는 CDN을 통해 서비스할 것
    - 각 계층은 독립적으로 서비스를 분할할 것
    - 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것